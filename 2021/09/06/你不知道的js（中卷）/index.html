<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="你不知道的js（中卷）, 楠神,laycoder,个人博客,个人网站,www.laycoder.com,楠神嘚儿驾">
    <meta name="description" content="laycoder.com，前端哒哒哒哒哒哒哒">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>你不知道的js（中卷） | lay coder</title>
    <link rel="icon" type="image/png" href="/medias/avatar.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.2"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/avatar.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">lay coder</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/avatar.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">lay coder</div>
        <div class="logo-desc">
            
            laycoder.com，前端哒哒哒哒哒哒哒
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">你不知道的js（中卷）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">笔记</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Javascript/" class="post-category">
                                Javascript
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-09-06
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="第一部分：类型和语法"><a href="#第一部分：类型和语法" class="headerlink" title="第一部分：类型和语法"></a>第一部分：类型和语法</h2><h3 id="第-1-章：类型"><a href="#第-1-章：类型" class="headerlink" title="第 1 章：类型"></a>第 1 章：类型</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>JavaScript 有七种内置类型：</p>
<ul>
<li>空值（null）</li>
<li>未定义（undefined）</li>
<li>布尔值（boolean）</li>
<li>数字（number）</li>
<li>字符串（string）</li>
<li>对象（object）</li>
<li>符号（symbol，ES6 中新增）</li>
</ul>
<p>除对象之外，其他统称为“基本类型”。<br>null 是基本类型中唯一的一个“假值”（falsy 或者 false-like，参见第 4 章）类型，typeof 对它的返回值为”object”</p>
<pre><code>typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;; // true
</code></pre>
<p>function（函数）实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性[[Call]]，该属性使其可以被调用。</p>
<p>函数不仅是对象，还可以拥有属性。例如：</p>
<pre><code>function a(b,c) &#123;    /* .. */&#125;
</code></pre>
<p>函数对象的 length 属性是其声明的参数的个数：</p>
<pre><code>a.length; // 2
</code></pre>
<p>因为该函数声明了两个命名参数，b 和 c，所以其 length 值为 2。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 有七种内置类型：null、undefined、boolean、number、string、object 和 symbol，可以使用 typeof 运算符来查看。<br>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。<br>很多开发人员将 undefined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。undefined 是值的一种。undeclared 则表示变量还没有被声明过。<br>遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问“undeclared”变量时这样报错：ReferenceError：a is not defined，并且 typeof 对 undefined 和 undeclared 变量都返回“undefined”。<br>然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的办法。</p>
<h3 id="第-2-章：值"><a href="#第-2-章：值" class="headerlink" title="第 2 章：值"></a>第 2 章：值</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><pre><code>    Number.parseFloat()     //将字符串转换成浮点数，和全局方法 parseFloat() 作用一致。
    Number.parseInt()       //将字符串转换成整型数字，和全局方法 parseInt() 作用一致。
    Number.isFinite()       //判断传递的参数是否为有限数字。
    Number.isInteger()      //判断传递的参数是否为整数。
    Number.isNaN()          //判断传递的参数是否为 isNaN()。
    Number.isSafeInteger()  //判断传递的参数是否为安全整数。

    toExponential()         //返回一个数字的指数形式的字符串，如：1.23e+2
    toFixed()                //返回指定小数位数的表示形式。
    toPrecision()           //返回一个指定精度的数字
</code></pre>
<h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><p>1、不是值的值<br>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名称既是类型也是值。<br>undefined 和 null 常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别。例如：</p>
<ul>
<li>null 指空值（empty value）</li>
<li>undefined 指没有值（missing value）</li>
</ul>
<p>或者：</p>
<ul>
<li>undefined 指从未赋值</li>
<li>null 指曾赋过值，但是目前没有值</li>
</ul>
<p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。<br>2、undefined<br>3、特殊的数字</p>
<ol>
<li><p>不是数字的数字<br> Number.isNaN(..)</p>
</li>
<li><p>无穷数<br> Infinity<br> 1/0 = Infinity<br> 1/-0 = -Infinity</p>
</li>
<li><p>零值<br> 区分-0 和 0，不能仅仅依赖开发调试窗口的显示结果，还需要做一些特殊处理：</p>
<pre><code>  function isNegZero(n) &#123;
      n = Number( n );
      return (n === 0) &amp;&amp; (1 / n === -Infinity);
  &#125;
  isNegZero( -0 );        // true
  isNegZero( 0 / -3 );    // true
  isNegZero( 0 );         // false
</code></pre>
</li>
<li><p>特殊等式<br> ES6 中新加入了一个工具方法 Object.is(..)来判断两个值是否绝对相等(主要用来处理那些特殊的相等比较)</p>
</li>
</ol>
<h4 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h4><p>JavaScript 中没有指针，引用的工作机制也不尽相同。在 JavaScript 中变量不可能成为指向另一个变量的引用。<br>JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用/指向关系。</p>
<p>简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值/传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。<br>复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值/传递。</p>
<h3 id="第-3-章：原生函数"><a href="#第-3-章：原生函数" class="headerlink" title="第 3 章：原生函数"></a>第 3 章：原生函数</h3><p>常用的原生函数有：</p>
<ul>
<li>String()</li>
<li>Number()</li>
<li>Boolean()</li>
<li>Array()</li>
<li>Object()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Date()</li>
<li>Error()</li>
<li>Symbol()</li>
</ul>
<p>new String(“abc”)创建的是字符串”abc”的封装对象，而非基本类型值”abc”。</p>
<h4 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性[[Class]]"></a>内部属性[[Class]]</h4><p>所有 typeof 返回值为”object”的对象（如数组）都包含一个内部属性[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..)来查看。</p>
<h4 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h4><p>一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什么时候应该使用封装对象。换句话说，就是应该优先考虑使用”abc”和 42 这样的基本类型值，而非 new String(“abc”)和 new Number(42)。</p>
<h5 id="封装对象释疑"><a href="#封装对象释疑" class="headerlink" title="封装对象释疑"></a>封装对象释疑</h5><pre><code>    a = new Boolean( true );
    a === true // false
    b = Boolean( true );
    b === true // true
</code></pre>
<h4 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h4><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf()函数</p>
<pre><code>    var a = new String( &quot;abc&quot; );
    var b = new Number( 42 );
    var c = new Boolean( true );
    a.valueOf(); // &quot;abc&quot;
    b.valueOf(); // 42
    c.valueOf(); // true
    // 或隐式拆封（强制类型转换）
    var a = new String( &quot;abc&quot; );
    var b = a + &quot;&quot;; // b的值为&quot;abc&quot;
    typeof a;       // &quot;object&quot;
    typeof b;       // &quot;string&quot;
</code></pre>
<h4 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h4><p>关于数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的（创建的值都是通过封装对象来包装）。<br>如前所述，应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的结果。</p>
<p>1、Array(…)<br>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length）， 而非只充当数组中的一个元素。Array.apply(null,{length:3})比 Array(3)更准确可靠<br>2、Object(…)、Function(…)和 RegExp(…)<br>同样，除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..)：<br>3、Date(…)和 Error(…)<br>创建日期对象必须使用 new Date()。Date(..)可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间。<br>构造函数 Error(..)（与前面的 Array()类似）带不带 new 关键字都可。创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分 JavaScript 引擎通过只读属性.stack 来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。<br>4、Symbol(…)<br>ES6 中新加入了一个基本数据类型——符号（Symbol）。符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。</p>
<pre><code>    const a = Symbol(&#39;a&#39;)
    const b = Symbol(&#39;a&#39;)
    const c = &#123;[a]: &#39;aaa&#39;,[b]: &#39;bbb&#39;&#125;
    console.log(c) // &#123;Symbol(a): &quot;aaa&quot;, Symbol(a): &quot;bbb&quot;&#125;
</code></pre>
<p>符号并非对象，而是一种简单标量基本类型。<br>5、原生原型</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 为基本数据类型值提供了封装对象，成为原生函数（如 String、Number、Boolean 等）。它们为基本数据类型值提供了该子类型所特有的方法和属性。<br>对于简单标量基本类型值，比如”abc”,如果要访问它的 length 属性或 string.prototype 方法，JavaScript 引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实现对这些属性和方法的访问。</p>
<h3 id="第-4-章：强制类型转换"><a href="#第-4-章：强制类型转换" class="headerlink" title="第 4 章：强制类型转换"></a>第 4 章：强制类型转换</h3><h4 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h4><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。<br>类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时。在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。<br>使用 Object.create(null)创建的对象[[Prototype]]属性为 null，并且没有 valueOf()和 toString()方法，因此无法进行强制类型转换。</p>
<h4 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h4><p>1、ToString<br>基本类型值的字符串化规则为：null 转换为”null”，undefined 转换为”undefined”，true 转换为”true”。NaN 为’NaN’<br>对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性[[Class]]的值<br>数组的默认 toString()方法经过了重新定义，将所有单元字符串化以后再用”,”连接起来：</p>
<pre><code>    var a = [1,2,3];
    a.toString(); // &quot;1,2,3&quot;
</code></pre>
<p>toString()可以被显式调用，或者在需要字符串化时自动调用。</p>
<h5 id="JSON-字符串化-工具函数-JSON-stringify-在将-JSON-对象序列化为字符串时也用到了-ToString。"><a href="#JSON-字符串化-工具函数-JSON-stringify-在将-JSON-对象序列化为字符串时也用到了-ToString。" class="headerlink" title="JSON 字符串化(工具函数 JSON.stringify(..)在将 JSON 对象序列化为字符串时也用到了 ToString。)"></a>JSON 字符串化(工具函数 JSON.stringify(..)在将 JSON 对象序列化为字符串时也用到了 ToString。)</h5><h5 id="所有安全的-JSON-值（JSON-safe）都可以使用-JSON-stringify-字符串化。安全的-JSON-值是指能够呈现为有效-JSON-格式的值。JSON-stringify-在对象中遇到-undefined、function-和-symbol-时会自动将其忽略，在数组中则会返回-null（以保证单元位置不变）。"><a href="#所有安全的-JSON-值（JSON-safe）都可以使用-JSON-stringify-字符串化。安全的-JSON-值是指能够呈现为有效-JSON-格式的值。JSON-stringify-在对象中遇到-undefined、function-和-symbol-时会自动将其忽略，在数组中则会返回-null（以保证单元位置不变）。" class="headerlink" title="所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..)字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。JSON.stringify(..)在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。"></a>所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..)字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。JSON.stringify(..)在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。</h5><p>2、ToNumber<br>其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>
<p>3、ToBoolean</p>
<ol>
<li>假值<br>JavaScript 中的值可以分为以下两类：<br>(1) 可以被强制类型转换为 false 的值<br>(2) 其他（被强制类型转换为 true 的值）</li>
<li>假值对象<br>Boolean(new Boolean(false)) // true<br>Boolean(new Boolean(0)) // true<br>Boolean(new Boolean(‘’)) // true<br>Boolean(document.all) // false</li>
<li>真值<br>真值就是假值列表之外的值。</li>
</ol>
<h4 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h4><p>1、字符串和数字之间的显示转换</p>
<ol>
<li>日期显示转换为数字</li>
</ol>
<p>+new Date(‘Sun Dec 12 2021 17:31:00 GMT+0800 (中国标准时间)’) // 1639301464548<br>不建议对日期类型使用强制类型转换，应该使用 Date.now()来获得当前的时间戳，使用 new Date(..).getTime()来获得指定时间的时间戳。</p>
<ol start="2">
<li><p>奇特的~运算符<br>它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”（对每一个字位进行反转）。<br>if (~a.indexOf(..))仍然是对 indexOf(..)的返回结果进行隐式强制类型转换，0 转换为 false，其他情况转换为 true。但我觉得~更像显式强制类型转换，前提是我对它有充分的理解。<br>~比&gt;= 0 和=== -1 更简洁。</p>
</li>
<li><p>字位截除<br>一些开发人员使用~~来截除数字值的小数部分，以为这和 Math.floor(..)的效果一样，实际上并非如此。<br>~~中的第一个~执行 ToInt32 并反转字位，然后第二个~再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。<br>对~~我们要多加注意。首先它只适用于 32 位数字，更重要的是它对负数的处理与 Math.floor(..)不同。</p>
<p>Math.floor( -49.6 ); // -50<br>~~-49.6; // -49</p>
</li>
</ol>
<p>~~x 能将值截除为一个 32 位整数，x | 0 也可以，而且看起来还更简洁。出于对运算符优先级的考虑，我们可能更倾向于使用~~x：</p>
<p>2、显式解析数字字符串<br>parseInt(..)针对的是字符串值。向 parseInt(..)传递数字和其他类型的参数是没有用的<br>parseInt(1/0, 19)实际上是 parseInt(“Infinity”, 19)。第一个字符是”I”，以 19 为基数时值为 18。第二个字符”n”不是一个有效的数字字符，解析到此为止，和”42px”中的”p”一样。</p>
<p>3、显式转换为布尔值<br>使用 Boolean(a)和!!a 来进行显式强制类型转换。</p>
<h4 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h4><p>1、隐式的简化<br>2、字符串和数字之间的隐式强制类型转换<br>3、布尔值到数字的隐式强制类型转换<br>4、隐式强制类型转换为布尔值<br>相对布尔值，数字和字符串操作中的隐式强制类型转换还算比较明显。下面的情况会发生<br>布尔值隐式强制类型转换。<br>(1) if (..) 语句中的条件判断表达式。<br>(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。<br>(3) while (..) 和 do..while(..) 循环中的条件判断表达式。<br>(4) ? : 中的条件判断表达式。<br>(5) 逻辑运算符 ||（逻辑或）和   （逻辑与）左边的操作数（作为条件判断表达式）。<br>5、||和&amp;&amp;<br>6、符号的强制类型转换<br>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换<br>为布尔值（显式和隐式结果都是 true）。</p>
<h4 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h4><p>宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相<br>等”<br>常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。听起来蛮有道理，然而<br>还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。<br>== 允许在相等比较中进行强制类型转换，而 === 不允许<br>1、相等比较操作的性能<br>如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎<br>实现上的细微差别之外，它们之间并没有什么不同。<br>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就用 ===，不用在乎性能。<br>2、抽象相等<br>ES5 规范 11.9.3 节的“抽象相等比较算法”定义了 == 运算符的行为。</p>
<ol>
<li><p>字符串和数字之间的相等比较<br> 字符串被强制类型转换为数字以便进行相等比较</p>
</li>
<li><p>其他类型和布尔类型之间的相等比较<br> == 两边的布尔值会被强制类型转换为数字。</p>
</li>
<li><p>null 和 undefined 之间的相等比较<br> 在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换</p>
</li>
<li><p>对象和非对象之间的相等比较<br> (1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；<br> (2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p>
</li>
<li><p>比较少见的情况</p>
<ol>
<li><p>返回其他数字</p>
<pre><code>  Number.prototype.valueOf = function() &#123;
     return 3;
  &#125;;
  new Number( 2 ) == 3; // true
</code></pre>
</li>
<li><p>假值的相等比较</p>
<pre><code> &quot;0&quot; == null; // false
 &quot;0&quot; == undefined; // false
 &quot;0&quot; == false; // true
 &quot;0&quot; == NaN; // false
 &quot;0&quot; == 0; // true
 &quot;0&quot; == &quot;&quot;; // false
 false == null; // false
 false == undefined; // false
 false == NaN; // false
 false == 0; // true
 false == &quot;&quot;; // true
 false == []; // true
 false == &#123;&#125;; // false
 &quot;&quot; == null; // false
 &quot;&quot; == undefined; // false
 &quot;&quot; == NaN; // false
 &quot;&quot; == 0; // true
 &quot;&quot; == []; // true
 &quot;&quot; == &#123;&#125;; // false
 0 == null; // false
 0 == undefined; // false
 0 == NaN; // false
 0 == []; // true
 0 == &#123;&#125;; // false
</code></pre>
</li>
<li><p>极端情况</p>
<pre><code> [] == ![] // true
 [] == []  // false
 [] === [] // false
 2 == [2]; // true
 &quot;&quot; == [null]; // true
 0 == &quot;\n&quot;; // true
</code></pre>
</li>
<li><p>完整性检查</p>
<pre><code> &quot;0&quot; == false; // true
 false == 0; // true
 false == &quot;&quot;; // true
 false == []; // true
 &quot;&quot; == 0; // true
 &quot;&quot; == []; // true
 0 == []; // true
 &quot;&quot; == 0; // true
 &quot;&quot; == []; // true
 0 == []; // true
</code></pre>
</li>
<li><p>安全运用隐式强制类型转换</p>
<ul>
<li><p>如果两边的值中有 true 或者 false，千万不要使用 ==。</p>
</li>
<li><p>如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。</p>
<p>这时最好用 === 来避免不经意的强制类型转换。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="抽象关系比较"><a href="#抽象关系比较" class="headerlink" title="抽象关系比较"></a>抽象关系比较</h4><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>强制类型转换包括显式和隐式<br>强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为有使命感的 JavaScript 开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。<br>显式强制类型转换明确告诉我们哪里发生了类型转换，有助于提高代码可读性和可维护性。<br>隐式强制类型转换则没有那么明显，是其他操作的副作用。感觉上好像是显式强制类型转换的反面，实际上隐式强制类型转换也有助于提高代码的可读性。<br>在处理强制类型转换的时候要十分小心，尤其是隐式强制类型转换。在编码的时候，要知其然，还要知其所以然，并努力让代码清晰易读。</p>
<h3 id="第-5-章：语法"><a href="#第-5-章：语法" class="headerlink" title="第 5 章：语法"></a>第 5 章：语法</h3><h4 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h4><p>语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词。<br>1、语句的结果值<br>虽然目前语句的结果值还无关紧要，但随着 JavaScript 语言的演进，它可能会扮演越来越<br>重要的角色。<br>2、表达式的副作用</p>
<pre><code>    var a = 42;
    var b = a++;
</code></pre>
<p>a++ 首先返回变量 a 的当前值 42（再将该值赋给 b），然后将 a 的值加 1：</p>
<pre><code>    var a = 42;
    var b = a++;
    a; // 43
    b; // 42
</code></pre>
<p>++ 在前面时，如 ++a，它的副作用（将 a 递增）产生在表达式返回结果值之前，而 a++ 的<br>副作用则产生在之后。<br>可以使用 , 语句系列逗号运算符（statement-series comma operator）将语法多个独立的表达式语句串联成一个语句：</p>
<pre><code>    var a = 42, b;
    b = ( a++, a );
    a; // 43
    b; // 43
</code></pre>
<p>3、上下文规则</p>
<ol>
<li><p>大括号<br> （1）对象常量<br> 用大括号定义对象常量（object literal）：</p>
<pre><code>     // 假定函数bar()已经定义
     var a = &#123;
         foo: bar()
     &#125;;
</code></pre>
<p> { .. } 被赋值给 a，因而它是一个对象常量。</p>
<pre><code>     （2）标签

             &#123;
                 foo: bar()
             &#125;
</code></pre>
<p> { .. } 在这里只是一个普通的代码块, 和 for/while 循环以及 if 条件语句中代码块的作用基本相同。<br> JavaScript 通过标签跳转能够实现 goto 的部分功能。continue 和 break 语句都可以带一个标签，因此能够像 goto 那样进行跳转。</p>
<pre><code>     // 标签为foo的循环
     foo: for (var i=0; i&lt;4; i++) &#123;
         for (var j=0; j&lt;4; j++) &#123;
             // 如果j和i相等，继续外层循环
             if (j == i) &#123;
                 // 跳转到foo的下一个循环
                 continue foo;
             &#125;
             // 跳过奇数结果
             if ((j * i) % 2 == 1) &#123;
             // 继续内层循环（没有标签的）
             continue;
             &#125;
             console.log( i, j );
         &#125;
     &#125;
     // 1 0
     // 2 0
     // 2 1
     // 3 0
     // 3 2
</code></pre>
<p> contine foo 并不是指“跳转到标签 foo 所在位置继续执行”，而是“执行 foo 循环的下一轮循环”。</p>
<pre><code>     // 标签为foo的循环
     foo: for (var i=0; i&lt;4; i++) &#123;
         for (var j=0; j&lt;4; j++) &#123;
             if ((i * j) &gt;= 3) &#123;
                 console.log( &quot;stopping!&quot;, i, j );
                 break foo;
             &#125;
             console.log( i, j );
         &#125;
     &#125;
     // 0 0
     // 0 1
     // 0 2
     // 0 3
     // 1 0
     // 1 1
     // 1 2
     // 停止！ 1 3
</code></pre>
<p> break foo 不是指“跳转到标签 foo 所在位置继续执行”，而是“跳出标签 foo 所在的循环 / 代码块，继续执行后面的代码”。</p>
</li>
<li><p>代码块</p>
<pre><code> [] + &#123;&#125;; // &quot;[object Object]&quot;
 &#123;&#125; + []; // 0
</code></pre>
</li>
</ol>
<p>第一行代码中，{} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。第 4 章讲过 [] 会被强制类型转换为 “”，而 {} 会被强制类型转换为 “[object Object]”。<br>在第二行代码中，{} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换（参见第 4 章）为 0。</p>
<ol start="3">
<li><p> 对象结构</p>
</li>
<li><p>else if 和可选代码块</p>
<pre><code>  if () &#123;...&#125;
  else &#123;
      if () &#123;...&#125;
  &#125;
 👇
 if () ...
 else if () &#123;...&#125;
 👇
 if () ...
 else if () ...
</code></pre>
<p> if (b) { .. } else { .. } 实际上是跟在 else 后面的一个单独的语句，所以带不带 { } 都<br> 可以。换句话说，else if 不符合前面介绍的编码规范，else 中是一个单独的 if 语句。这只是我们自己发明的用法</p>
</li>
</ol>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>1、短路<br>2、更强的绑定<br>3、关联<br>4、释疑</p>
<h4 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h4><p>有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic Semicolon<br>Insertion，ASI）。<br>ASI 只在换行符处起作用，而不会在代码行的中间插入分号。</p>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><h4 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h4><p>如果 finally 中抛出异常（无论是有意还是无意），函数就会在此处终止。如果此前 try 中<br>已经有 return 设置了返回值，则该值会被丢弃<br>finally 中的 return 会覆盖 try 和 catch 中 return 的返回值</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>有时可能会需要通过强制类型转换来进行相等比较（即 ==，参见第 4 章），这时就需要做一些特殊处理：</p>
<pre><code>    var a = &quot;42&quot;;
    switch (true) &#123;
        case a == 10:
            console.log( &quot;10 or &#39;10&#39;&quot; );
        break;
        case a == 42;
            console.log( &quot;42 or &#39;42&#39;&quot; );
        break;
        default:
        // 永远执行不到这里
    &#125;
    // 42 or &#39;42&#39;
</code></pre>
<p>除简单值以外，case 中还可以出现各种表达式，它会将表达式的结果值和 true 进行比较。因为 a == 42 的结果为 true，所以条件成立。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>语句和表达式在英语中都能找到类比——语句就像英语中的句子，而表达式就像短语。表达式可以是简单独立的，否则可能会产生副作用。<br>JavaScript 语法规则之上是语义规则（也称作上下文）。例如，{ } 在不同情况下的意思不尽相同，可以是语句块、对象常量、解构赋值（ES6）或者命名函数参数（ES6）。<br>JavaScript 详细定义了运算符的优先级（运算符执行的先后顺序）和关联（多个运算符的组合方式）。只要熟练掌握了这些规则，就能对如何合理地运用它们作出自己的判断。<br>ASI（自动分号插入）是 JavaScript 引擎的代码解析纠错机制，它会在需要的地方自动插入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的（可以省略），或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。<br>JavaScript 中有很多错误类型，分为两大类：早期错误（编译时错误，无法被捕获）和运行时错误（可以通过 try..catch 来捕获）。所有语法错误都是早期错误，程序有语法错误则无法运行。<br>函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组，它的抽象泄漏给我们挖了不少坑。因此，尽量不要使用 arguments，如果非用不可，也切勿同时使用 arguments 和其对应的命名参数。<br>finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场，但也容易引起困惑，特别是在和带标签的代码块混用时。总之，使用 finally 旨在让代码更加简洁易读，切忌弄巧成拙。<br>switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是，如果对其理解得不够透彻，稍不注意就很容易出错。</p>
<h3 id="第二部分：异步和性能"><a href="#第二部分：异步和性能" class="headerlink" title="第二部分：异步和性能"></a>第二部分：异步和性能</h3><h3 id="第-1-章：异步：现在与将来"><a href="#第-1-章：异步：现在与将来" class="headerlink" title="第 1 章：异步：现在与将来"></a>第 1 章：异步：现在与将来</h3><h4 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h4><p>任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点<br>击、Ajax 响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序<br>中引入了异步机制。</p>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>JavaScript 引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是 Web 浏览器。经过最近几年（不仅于此）的发展，JavaScript 已经超出了浏览器的范围，进入了其他环境，比如通过像 Node.js 这样的工具进入服务器领域。<br>所有这些环境都有一个共同“点”（thread，也指线程。不论真假与否，这都不算一个很精妙的异步笑话），即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为事件循环。<br>JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”（JavaScript 代码执行）调度总是由包含它的环境进行。### 第 2 章：回调<br>ES6 从本质上改变了在哪里管理事件循环。本来它几乎已经是一种正式的技术模型了，但现在 ES6 精确指定了事件循环的工作细节，这意味着在技术上将其纳入了 JavaScript 引擎的势力范围，而不是只由宿主环境管理。这个改变的一个主要原因是 ES6 中 Promise 的引入，因为这项技术要求对事件循环队列的调度运行能够直接进行精细控制</p>
<h4 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h4><p>术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。<br>并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。</p>
<p>与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。<br>并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>两个或多个“进程”同时执行就出现了并发，不管组成它们的单个运算是否并行执行（在独立的处理器或处理器核心上同时运行）。可以把并发看作“进程”级（或者任务级）的并行，与运算级的并行（不同处理器上的线程）相对<br>单线程事件循环是并发的一种形式<br>1、非交互<br>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤 / 事件时，如果这些任务彼此不相关，就不一定需要交互。<br>2、交互<br>并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。需要对它们的交互进行协调以避免竞态的出现。<br>另一种可能遇到的并发交互条件有时称为竞态（race），但是更精确的叫法是门闩（latch）。它的特性可以描述为“只有第一名取胜”。在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要“竞争”到终点，且只有唯一的胜利者。<br>3、协作<br>还有一种并发合作方式，称为并发协作（cooperative concurrency）。这里的重点不再是通过共享作用域中的值进行交互（尽管显然这也是允许的！）。这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>在 ES6 中，有一个新的概念建立在事件循环队列之上，叫作任务队列（job queue）。这个概念给大家带来的最大影响可能是 Promise 的异步特性</p>
<h4 id="语句顺序"><a href="#语句顺序" class="headerlink" title="语句顺序"></a>语句顺序</h4><p>代码中语句的顺序和 JavaScript 引擎执行语句的顺序并不一定要一致。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>实际上，JavaScript 程序总是至少分为两个块：第一块现在运行；下一块将来运行，以响应牟哥事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，<br>所以对状态的修改都是在之前累计的修改之上进行的。<br>一旦有时间需要运行，事件循环就会运行，知道队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。<br>任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。<br>并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看。就像是同时在运行（尽管在任意时刻只处理一个事件）。<br>通常需要对这些并发执行“进程”（有别于操作系统中的进程概念）进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割为更小的块，以便其他“进程”插入进来。</p>
<h3 id="第-2-章：回调"><a href="#第-2-章：回调" class="headerlink" title="第 2 章：回调"></a>第 2 章：回调</h3><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟，对于异步编程领域的发展，回调已经不够用了。<br>第一，大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码时坏代码，会导致坏 bug。<br>我们需要一种更同步、更顺序、更阻塞的方式来表达异步，就像我们的大脑一样。<br>第二，也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三方（通常是不受你控制的第三方工具！）来调用你代码中的 continuation。这种控制转移导致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。<br>可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码，并且缺少足够的保护，其中的损害要知道你受到 bug 的影响才会被发现。<br>我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可以复用，且没有重复代码的开销。<br>我们需要比回调更好的机制。</p>
<h3 id="第-3-章：Promise"><a href="#第-3-章：Promise" class="headerlink" title="第 3 章：Promise"></a>第 3 章：Promise</h3><p>Promise 是一种封装和组合未来值的易于复用的机制。</p>
<h4 id="Promise-模式"><a href="#Promise-模式" class="headerlink" title="Promise 模式"></a>Promise 模式</h4><p>1、Promise.all([ .. ])<br>从 Promise.all([ .. ]) 返回的主 promise 在且仅在所有的成员 promise 都完成后才会完<br>成。如果这些 promise 中有任何一个被拒绝的话，主 Promise.all([ .. ])promise 就会立<br>即被拒绝，并丢弃来自其他所有 promise 的全部结果。<br>2、Promise.race([ .. ])<br>一旦有任何一个 Promise 决议为完成，Promise.race([ .. ])<br>就会完成；一旦有任何一个 Promise 决议为拒绝，它就会拒绝。<br>3、all([ .. ]) 和 race([ .. ]) 的变体<br>有些 Promise 抽象库提供了这些支持，但也可以使用 Promise、race([ .. ]) 和 all([ .. ])<br>这些机制，你自己来实现它们。</p>
<ul>
<li>none([ .. ])<br>这个模式类似于 all([ .. ])，不过完成和拒绝的情况互换了。所有的 Promise 都要被拒绝，即拒绝转化为完成值，反之亦然。</li>
<li>any([ .. ])<br>这个模式与 all([ .. ]) 类似，但是会忽略拒绝，所以只需要完成一个而不是全部。</li>
<li>first([ .. ])<br>这个模式类似于与 any([ .. ]) 的竞争，即只要第一个 Promise 完成，它就会忽略后续的任何拒绝和完成。</li>
<li>last([ .. ])<br>这个模式类似于 first([ .. ])，但却是只有最后一个完成胜出。</li>
</ul>
<p>4、并发迭代</p>
<pre><code>    var p1 = Promise.resolve( 21 );
    var p2 = Promise.resolve( 42 );
    var p3 = Promise.reject( &quot;Oops&quot; );
    // 把列表中的值加倍，即使是在 Promise 中
    Promise.map( [p1,p2,p3], function(pr,done)&#123;
        // 保证这一条本身是一个 Promise
        Promise.resolve( pr )
        .then(
        // 提取值作为 v
            function(v)&#123;
            // map 完成的 v 到新值
            done( v \* 2 );
            &#125;,
            // 或者 map 到 promise 拒绝消息
            done
        );
        &#125; )
        .then( function(vals)&#123;
            console.log( vals ); // [42,84,&quot;Oops&quot;]
    &#125; );
</code></pre>
<h4 id="Promise-API-概述"><a href="#Promise-API-概述" class="headerlink" title="Promise API 概述"></a>Promise API 概述</h4><p>1、new Promise(..)构造器<br>有启示性的构造器 Promise(..) 必须和 new 一起使用，并且必须提供一个函数回调。这个回调是同步的或立即调用的。这个函数接受两个函数回调，用以支持 promise 的决议。通常我们把这两个函数称为 resolve(..) 和 reject(..)<br>2、Promise.resolve(..) 和 Promise.reject(..)<br>创建一个已被拒绝的 Promise 的快捷方式是使用 Promise.reject(..)，所以以下两个<br>promise 是等价的：</p>
<pre><code>    var p1 = new Promise( function(resolve,reject)&#123;
        reject( &quot;Oops&quot; );
    &#125; );
    var p2 = Promise.reject( &quot;Oops&quot; );
</code></pre>
<p>Promise.resolve(..) 常用于创建一个已完成的 Promise，使用方式与 Promise.reject(..)类似。但是，Promise.resolve(..) 也会展开 thenable 值（前面已多次介绍）。在这种情况<br>下，返回的 Promise 采用传入的这个 thenable 的最终决议值，可能是完成，也可能是拒绝<br>如果传入的是真正的 Promise，Promise.resolve(..) 什么都不会做，只会直接把这个值返回。所以，对你不了解属性的值调用 Promise.resolve(..)，如果它恰好是一个真正的 Promise，是不会有额外的开销的。<br>3、then(..) 和 catch(..)<br>then(..) 接受一个或两个参数：第一个用于完成回调，第二个用于拒绝回调。如果两者中的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回调只是把消息传递下去，而默认拒绝回调则只是重新抛出（传播）其接收到的出错原因。<br>catch(..) 只接受一个拒绝回调作为参数，并自动替换默认完成回调。它等价于 then(null,..)<br>then(..) 和 catch(..) 也会创建并返回一个新的 promise，这个 promise 可以用于实现 Promise 链式流程控制。如果完成或拒绝回调中抛出异常，返回的 promise 是被拒绝的。如果任意一个回调返回非 Promise、非 thenable 的立即值，这个值会被用作返回 promise 的完成值。如果完成处理函数返回一个 promise 或 thenable，那么这个值会被展开，并作为返回 promise 的决议值。<br>4、Promise.all([ .. ]) 和 Promise.race([ .. ])<br>ES6 Promise API 静态辅助函数 Promise.all([ .. ]) 和 Promise.race([ .. ]) 都会创建一个 Promise 作为它们的返回值。这个 promise 的决议完全由传入的 promise 数组控制。<br>若向 Promise.all([ .. ]) 传入空数组，它会立即完成，但 Promise.race([ .. ]) 会挂住，且永远不会决议。</p>
<h4 id="Promise-局限性"><a href="#Promise-局限性" class="headerlink" title="Promise 局限性"></a>Promise 局限性</h4><p>1、顺序错误处理<br>Promise 链中的错误很容易被无意中默默忽略掉。<br>如果构建了一个没有错误处理函数的 Promise 链，链中任何地方的任何错误都会在链中一直传播下去，直到被查看（通过在某个步骤注册拒绝处理函数）。<br>基本上，这等同于 try..catch 存在的局限：try..catch 可能捕获一个异常并简单地吞掉<br>它。所以这并不是 Promise 独有的局限性<br>2、单一值</p>
<ol>
<li>分裂值</li>
<li>展开/传递参数</li>
</ol>
<p>3、单决议<br>Promise 最本质的一个特征是：Promise 只能被决议一次（完成或拒绝）。<br>但是，还有很多异步的情况适合另一种模式——一种类似于事件和 / 或数据流的模式。在表面上，目前还不清楚 Promise 能不能很好用于这样的用例，如果不是完全不可用的话。如果不在 Promise 之上构建显著的抽象，Promise 肯定完全无法支持多值决议处理。<br>4、惯性<br>5、无法取消的 Promise<br>一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。<br>6、性能<br>把基本的基于回调的异步任务链与 Promise 链中需要移动的部分数量进行比较。很显然，Promise 进行的动作要多一些，这自然意味着它也会稍慢一些。</p>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>Promise 非常好，请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。它们并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任的中介机制。<br>Promise 链也开始提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步 JavaScript 代码。我们将在第 4 章看到针对这个问题的一种更好的解决方案！</p>
<h3 id="第-4-章：生成器"><a href="#第-4-章：生成器" class="headerlink" title="第 4 章：生成器"></a>第 4 章：生成器</h3><h4 id="打破完整运行"><a href="#打破完整运行" class="headerlink" title="打破完整运行"></a>打破完整运行</h4><pre><code>    var x = 1;
    function* foo() &#123;
        x++;
        yield; // 暂停！
        console.log( &quot;x:&quot;, x );
    &#125;
    function bar() &#123;
        x++;
    &#125;
    // 构造一个迭代器it来控制这个生成器
    var it = foo();
    // 这里启动foo()！
    it.next();
    x; // 2
    bar();
    x; // 3
    it.next(); // x: 3
</code></pre>
<p>因此，生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。<br>运行过程<br>(1) it = foo() 运算并没有执行生成器 *foo()，而只是构造了一个迭代器（iterator），这个迭代器会控制它的执行。后面会介绍迭代器。<br>(2) 第一个 it.next() 启动了生成器 *foo()，并运行了 <em>foo() 第一行的 x++。<br>(3) *foo() 在 yield 语句处暂停，在这一点上第一个 it.next() 调用结束。此时 *foo() 仍在运行并且是活跃的，但处于暂停状态。<br>(4) 我们查看 x 的值，此时为 2。<br>(5) 我们调用 bar()，它通过 x++ 再次递增 x。<br>(6) 我们再次查看 x 的值，此时为 3。<br>(7) 最后的 it.next() 调用从暂停处恢复了生成器 \</em>foo() 的执行，并运行 console.log(..)语句，这条语句使用当前 x 的值 3。</p>
<p>foo() 启动了，但是没有完整运行，它在 yield 处暂停了。后面恢复了 foo() 并让它运行到结束，但这不是必需的。</p>
<p>生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。</p>
<p>1、输入和输出<br>next(..) 调用的结果是一个对象，它有一个 value 属性，持有从 *foo(..) 返回的值（如果有的话）。换句话说，yield 会导致生成器在执行过程中发送出一个值，这有点类似于中间的 return。</p>
<ol>
<li><p>迭代消息传递<br> 除了能够接受参数并提供返回值之外，生成器甚至提供了更强大更引人注目的内建消息输入输出能力，通过 yield 和 next(..) 实现。</p>
<pre><code>  function *foo(x) &#123;
     var y = x * (yield);
     return y;
  &#125;
  var it = foo( 6 );
  // 启动foo(..)
  it.next();
  var res = it.next( 7 );
  res.value; // 42
</code></pre>
</li>
<li><p>两个问题的故事<br> 没有向第一个 next() 调用发送值，这是有意为之。只有暂停的 yield 才能接受这样一个通过 next(..) 传递的值，而在生成器的起始处我们调用第一个 next() 时，还没有暂停的 yield 来接受这样一个值。</p>
</li>
</ol>
<p>2、多个迭代器<br>每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。<br>同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互：</p>
<pre><code>    function *foo() &#123;
        var x = yield 2;
        z++;
        var y = yield (x * z);
        console.log( x, y, z );
    &#125;
    var z = 1;
    var it1 = foo();
    var it2 = foo();
    var val1 = it1.next().value;            // 2 &lt;-- yield 2
    var val2 = it2.next().value;            // 2 &lt;-- yield 2
    val1 = it1.next( val2 * 10 ).value;     // 40 &lt;-- x:20, z:2
    val2 = it2.next( val1 * 5 ).value;      // 600 &lt;-- x:200, z:3
    it1.next( val2 / 2 );                   // y:300
                                            // 20 300 3
    it2.next( val1 / 4 );                   // y:10
                                            // 200 10 3
</code></pre>
<p>执行流程<br>(1) *foo() 的两个实例同时启动，两个 next() 分别从 yield 2 语句得到值 2。<br>(2) val2 * 10 也就是 2 * 10，发送到第一个生成器实例 it1，因此 x 得到值 20。z 从 1 增<br>加到 2，然后 20 * 2 通过 yield 发出，将 val1 设置为 40。<br>(3) val1 * 5 也就是 40 * 5，发送到第二个生成器实例 it2，因此 x 得到值 200。z 再次从 2<br>递增到 3，然后 200 * 3 通过 yield 发出，将 val2 设置为 600。<br>(4) val2 / 2 也就是 600 / 2，发送到第一个生成器实例 it1，因此 y 得到值 300，然后打印<br>出 x y z 的值分别是 20 300 3。<br>(5) val1 / 4 也就是 40 / 4，发送到第二个生成器实例 it2，因此 y 得到值 10，然后打印出<br>x y z 的值分别为 200 10 3。</p>
<h3 id="第-5-章：程序性能"><a href="#第-5-章：程序性能" class="headerlink" title="第 5 章：程序性能"></a>第 5 章：程序性能</h3><h3 id="第-6-章：性能测试与调优"><a href="#第-6-章：性能测试与调优" class="headerlink" title="第 6 章：性能测试与调优"></a>第 6 章：性能测试与调优</h3>
                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">笔记</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/12/08/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/10.png" class="responsive-img" alt="你不知道的js（下卷）">
                        
                        <span class="card-title">你不知道的js（下卷）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-12-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Javascript/" class="post-category">
                                    Javascript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">笔记</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/05/08/%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87-%E6%96%87%E5%AD%97/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="复制图片+文字">
                        
                        <span class="card-title">复制图片+文字</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Javascript/" class="post-category">
                                    Javascript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">笔记</span>
                    </a>
                    
                    <a href="/tags/Javascript/">
                        <span class="chip bg-color">Javascript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2018-2023</span>
            
            <span id="year">2018</span>
            <a href="/about" target="_blank">laycoder</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
            <span id="icp"><img src="/medias/icp.png" style="vertical-align: text-bottom;" />
                <a href="http://beian.miit.gov.cn/" target="_blank">宁ICP备20000554号</a>
            </span>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/zn-nz" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:898468959@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=898468959" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 898468959" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
