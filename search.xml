<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>element-plus【常用表格curd功能hooks封装】</title>
      <link href="/2023/08/04/element-plus%E3%80%90%E5%B8%B8%E7%94%A8%E8%A1%A8%E6%A0%BCcurd%E5%8A%9F%E8%83%BDhooks%E5%B0%81%E8%A3%85%E3%80%91/"/>
      <url>/2023/08/04/element-plus%E3%80%90%E5%B8%B8%E7%94%A8%E8%A1%A8%E6%A0%BCcurd%E5%8A%9F%E8%83%BDhooks%E5%B0%81%E8%A3%85%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>###基于表格封装 hooks 封装</p><pre><code>import _Table from &quot;@/components/zn-table/index.vue&quot;;import &#123; ElLoading, ElMessage, ElMessageBox &#125; from &quot;element-plus&quot;;import &#123; downloadFile, obj2Formdata, selectLocalFile, typeCheck &#125; from &quot;@/utils/utils&quot;;import &#123; fileType &#125; from &quot;@/constant&quot;;import debounce from &quot;@/utils/debounce&quot;;import &#123; ref, reactive, toRefs, onBeforeMount, h &#125; from &quot;vue&quot;;export const dialogTypeOpt = &#123;  create: &quot;create&quot;,  update: &quot;update&quot;,  detail: &quot;detail&quot;&#125;;/*** @param &#123;&#123;    * data:&#123;    * [string]:any    * &#125; // 需要初始化的变量    * methods:&#123;    * [string]:Function    * &#125; // 需要覆盖的方法    * apiOpt:&#123;    * detailIdKey:string // 详情id键值    * list:Promise // 列表接口    * create:Promise // 创建接口    * del:Promise // 删除接口    * detail:Promise // 详情接口    * update:Promise // 修改接口    * import:Promise // 导入接口    * download:Promise // 导出接口    * &#125;    * &#125;&#125; param* @returns*/export const useTable = (&#123; data, apiOpt, methods &#125; = &#123;&#125;) =&gt; &#123;  const formRef = ref();  const _data = reactive(&#123;    tableData: [],    tableQuery: &#123;      pageIndex: 1,      pageSize: 20    &#125;,    temp: &#123;&#125;,    dialogVisible: false,    total: 0,    tableLoading: false,    handleLoading: false,    dialogTypeOpt,    dialogType: &quot;&quot;,    dialogTitleMap: &#123;      [dialogTypeOpt.create]: &quot;新增&quot;,      [dialogTypeOpt.update]: &quot;修改&quot;,      [dialogTypeOpt.detail]: &quot;详情&quot;    &#125;,    fileName: null,    ...data  &#125;);  let debounceFun;  onBeforeMount(() =&gt; &#123;    _methods.fetchData();    _methods.getTableData();  &#125;);  const _methods = &#123;    handleSearch() &#123;      _data.tableQuery.pageIndex = 1;      _data.total = 0;      if (!debounceFun) &#123;        debounceFun = debounce(_methods.getTableData, 0);      &#125;      debounceFun();    &#125;,    showConfirm(cb) &#123;      ElMessageBox.confirm(&quot;是否确定此操作？&quot;, &quot;系统提示&quot;, &#123;        type: &quot;warning&quot;,        autofocus: false      &#125;)        .then(cb)        .catch();    &#125;,    // 查    async getTableData() &#123;      if (apiOpt?.list) &#123;        const query = _methods.getTableQuery();        if (query === false) &#123;          _data.total = 0;          _data.tableData = [];          return;        &#125;        _data.tableLoading = true;        const response = await apiOpt.list(query);        _methods.getTableDataNormalSuccess(response);      &#125; else &#123;        console.log(&quot;未定义list接口或getTableData方法&quot;);      &#125;    &#125;,    getTableQuery() &#123;      return _data.tableQuery;    &#125;,    // 校验并操作    handleConfirm() &#123;      formRef.value?.validate((valid) =&gt; &#123;        if (valid) &#123;          switch (_data.dialogType) &#123;            case dialogTypeOpt.create:              _methods.confirmCreate();              break;            case dialogTypeOpt.update:              _methods.confirmUpdate();              break;            default:              _methods.confirmHandle?.();              break;          &#125;        &#125;      &#125;);    &#125;,    confirmHandle() &#123;&#125;,    // 增    handleCreate() &#123;      _methods.resetTemp();      _data.dialogType = dialogTypeOpt.create;      _data.dialogVisible = true;    &#125;,    // 确定创建    async confirmCreate() &#123;      if (apiOpt?.create) &#123;        const query = _methods.getCreateQuery();        _data.handleLoading = true;        const response = await apiOpt.create(query).catch(() =&gt; (_data.handleLoading = false));        _methods.handleSuccess(response);      &#125; else &#123;        console.log(&quot;未定义create接口或confirmCreate方法&quot;);      &#125;    &#125;,    getCreateQuery() &#123;      return _data.temp;    &#125;,    // 删    handleDelete(data, cb) &#123;      _data.temp = data;      _methods.showConfirm(cb || _methods.confirmDelete);    &#125;,    // 批量删除    handleBatchDel(cb) &#123;      _methods.showConfirm(cb || _methods.confirmBatchDelete);    &#125;,    confirmBatchDelete() &#123;      console.log(&quot;未定义confirmBatchDelete方法&quot;);    &#125;,    // 确定删除    async confirmDelete() &#123;      if (apiOpt?.del) &#123;        const query = _methods.getDelQuery();        if (query === false) return;        const response = await apiOpt.del(query);        _methods.handleSuccess(response);      &#125; else &#123;        console.log(&quot;未定义del接口或confirmDelete方法&quot;);      &#125;    &#125;,    getDelQuery() &#123;      if (!_data.temp.id) &#123;        alert(&quot;找后端要列表id&quot;);        return false;      &#125;      return &#123; id: _data.temp.id &#125;;    &#125;,    // 改之前摇    async handleUpdateBefore(row, next) &#123;      const data = await _methods.getDetailData(row);      if (data === false) return;      _methods.handleUpdate(data, next);    &#125;,    async getDetailData(row) &#123;      if (apiOpt?.detail) &#123;        const query = _methods.getDetailQuery(row);        if (query === false) return;        const &#123; ok, data &#125; = await apiOpt.detail(query);        if (ok) &#123;          return data;        &#125;      &#125; else &#123;        console.log(&quot;未定义detail接口或handleUpdateBefore方法&quot;);      &#125;      return false;    &#125;,    getDetailQuery(&#123; id &#125;) &#123;      if (!id) &#123;        alert(&quot;找后端要列表id&quot;);        return false;      &#125;      return &#123; [apiOpt.detailIdKey || &quot;id&quot;]: id &#125;;    &#125;,    // 改    handleUpdate(row, next) &#123;      _methods.resetTemp();      _data.temp = &#123; ...row &#125;;      if (typeCheck(next) === &quot;[object Function]&quot; || typeCheck(next) === &quot;[object AsyncFunction]&quot;) &#123;        next(row);      &#125;      _data.dialogType = dialogTypeOpt.update;      _data.dialogVisible = true;    &#125;,    // 确定修改    async confirmUpdate() &#123;      if (apiOpt?.update) &#123;        const query = _methods.getUpdateQuery();        _data.handleLoading = true;        const response = await apiOpt.update(query).catch(() =&gt; (_data.handleLoading = false));        _methods.handleSuccess(response);      &#125; else &#123;        console.log(&quot;未定义update接口或confirmUpdate方法&quot;);      &#125;    &#125;,    getUpdateQuery() &#123;      return _data.temp;    &#125;,    // 增删改成功    handleSuccess(&#123; ok &#125;) &#123;      _data.handleLoading = false;      if (ok) &#123;        ElMessage.closeAll(&quot;success&quot;);        ElMessage.success(&quot;操作成功&quot;);        _data.dialogVisible = false;        _methods.getTableData();      &#125;    &#125;,    //详情    async handleDetails(row, next) &#123;      const data = await _methods.getDetailData(row);      if (data === false) return;      _methods.resetTemp();      _data.temp = &#123; ...data &#125;;      if (typeCheck(next) === &quot;[object Function]&quot; || typeCheck(next) === &quot;[object AsyncFunction]&quot;) &#123;        next(data);      &#125;      _data.dialogType = dialogTypeOpt.detail;      _data.dialogVisible = true;    &#125;,    getTableDataNormalSuccess(&#123; ok, data, count &#125;) &#123;      _data.tableLoading = false;      if (ok) &#123;        _data.tableData = data;        _data.total = count ?? data.length;      &#125; else &#123;        _data.tableData = [];      &#125;    &#125;,    // 页码    handleCurrentChange(pageIndex) &#123;      _data.tableQuery.pageIndex = pageIndex;      _methods.getTableData();    &#125;,    // 单页数据量    handleSizeChange(pageSize) &#123;      _data.tableQuery.pageIndex = 1;      _data.tableQuery.pageSize = pageSize;      _methods.getTableData();    &#125;,    resetTemp() &#123;      _data.temp = &#123;&#125;;      formRef.value?.resetFields();    &#125;,    reset() &#123;      _data.tableQuery = &#123;        pageIndex: 1,        pageSize: 20      &#125;;      _methods.getTableData();    &#125;,    async handleImport() &#123;      if (apiOpt?.import) &#123;        const file = await selectLocalFile(fileType.xlsx);        const query = _methods.getImportQuery(file);        _data.handleLoading = true;        const loading = ElLoading.service(&#123; lock: true, text: &quot;正在导入，请稍后&quot; &#125;);        const response = await apiOpt.import(obj2Formdata(query));        loading.close();        _methods.handleImportSuccess(response);      &#125; else &#123;        console.log(&quot;未定义import接口或handleImport方法&quot;);      &#125;    &#125;,    // 上传接口调用成功    handleImportSuccess(res) &#123;      _data.handleLoading = false;      const type = typeCheck(res);      switch (true) &#123;        case type === &quot;[object Object]&quot;:          _methods.handleImportSomeSuccess(res);          break;        case type === &quot;[object Blob]&quot; &amp;&amp; res.type.includes(&quot;json&quot;):          &#123;            const reader = new FileReader();            reader.readAsText(res, &quot;utf-8&quot;);            reader.onload = () =&gt; &#123;              _methods.handleImportSomeSuccess(JSON.parse(reader.result));            &#125;;          &#125;          break;        case type === &quot;[object Blob]&quot;:          _methods.getTableData();          ElMessageBox.alert(&quot;部分上传成功，请修改失败的部分重新上传&quot;, &quot;系统提示&quot;, &#123; autofocus: false, type: &quot;warning&quot; &#125;);          downloadFile(res, &quot;导入失败部分.xlsx&quot;);          break;        default:          break;      &#125;    &#125;,    // 上传内容部分成功    handleImportSomeSuccess(res) &#123;      const &#123; ok, data &#125; = res;      if (ok) &#123;        const &#123; errorCount &#125; = data || &#123;&#125;;        if (!errorCount) &#123;          // 全部成功，没有失败          _methods.handleSuccess(res);        &#125; else &#123;          // 部分成功，对失败部分处理成表格          ElMessageBox.alert(&quot;部分上传成功，请修改失败的部分重新上传&quot;, &quot;系统提示&quot;, &#123; autofocus: false, type: &quot;warning&quot; &#125;);          _methods.handleImportError(res);        &#125;      &#125;    &#125;,    // 上传内容部分失败处理    handleImportError() &#123;      console.log(&quot;未定义handleImportError方法&quot;);    &#125;,    getImportQuery(file) &#123;      return &#123; file &#125;;    &#125;,    async handleDownload() &#123;      if (apiOpt?.download) &#123;        const query = _methods.getDownloadQuery();        _data.handleLoading = true;        // responseType: &quot;blob&quot;        const response = await apiOpt.download(query);        _data.handleLoading = false;        downloadFile(response, `$&#123;_data.fileName || Date.now()&#125;.xlsx`);        return Promise.resolve();      &#125; else &#123;        console.log(&quot;未定义download接口或handleDownload方法&quot;);      &#125;    &#125;,    getDownloadQuery() &#123;      return null;    &#125;,    // 获取表格模板    async handleTemplate() &#123;      console.log(&quot;未定义handleTemplate方法&quot;);    &#125;,    fetchData() &#123;&#125;,    ...methods  &#125;;  const Table = (props, &#123; slots &#125;) =&gt; &#123;    return h(      _Table,      &#123;        data: _data.tableData,        total: _data.total,        tableQuery: _data.tableQuery,        loading: _data.tableLoading,        ...props,        onHandleSizeChange: _methods.handleSizeChange,        onHandleCurrentChange: _methods.handleCurrentChange,        onHandleBatchDel: _methods.handleBatchDel      &#125;,      slots    );  &#125;;  return &#123; Table, formRef, ...toRefs(_data), ..._methods &#125;;&#125;;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>element-plus【表格二次封装】</title>
      <link href="/2023/04/10/element-plus%E3%80%90%E8%A1%A8%E6%A0%BC%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%E3%80%91/"/>
      <url>/2023/04/10/element-plus%E3%80%90%E8%A1%A8%E6%A0%BC%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%E3%80%91/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;template&gt;  &lt;div v-loading=&quot;loading&quot; class=&quot;zn-table-content&quot; :style=&quot;&#123; height &#125;&quot;&gt;    &lt;el-table ref=&quot;tableRef&quot; class=&quot;flex-1&quot; :class=&quot;&#123; &#39;hide-checkAll&#39;: hideDftCheckAll &amp;&amp; !headSelect &#125;&quot;    :data=&quot;data&quot;      @selection-change=&quot;handleSelectionChange&quot; v-bind=&quot;$attrs&quot;&gt;      &lt;el-table-column v-if=&quot;showSelect&quot; type=&quot;selection&quot; width=&quot;55&quot; align=&quot;center&quot;&gt;        &lt;template #header&gt;          &lt;i&gt;&lt;/i&gt;        &lt;/template&gt;        &lt;template #default=&quot;scope&quot;&gt;          &lt;slot name=&quot;select&quot; v-bind=&quot;scope&quot;&gt;            &lt;el-checkbox              :disabled=&quot;selectDisabled &amp;&amp; selectDisabled(scope.row)&quot;              :model-value=&quot;transferCheckedStatus(scope.store, scope.row)&quot;              @change=&quot;scope.store.toggleRowSelection(scope.row)&quot;            &gt;&lt;/el-checkbox&gt;          &lt;/slot&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column v-if=&quot;showIndex&quot; label=&quot;序号&quot; type=&quot;index&quot; align=&quot;center&quot; width=&quot;70&quot;&gt;        &lt;template #default=&quot;&#123; $index, row &#125;&quot;&gt;&#123;&#123; indexFormat($index, row) &#125;&#125;&lt;/template&gt;      &lt;/el-table-column&gt;      &lt;slot&gt;&lt;/slot&gt;      &lt;template v-if=&quot;customEmpty&quot; #empty&gt;        &lt;div&gt;          &lt;el-empty v-if=&quot;!loading&quot; style=&quot;width: 100%; height: 100%&quot; /&gt;        &lt;/div&gt;      &lt;/template&gt;      &lt;template #append&gt;        &lt;slot name=&quot;append&quot;&gt; &lt;/slot&gt;        &lt;div v-if=&quot;data?.length &amp;&amp; showBatchDel&quot; class=&quot;flex al-center p-y-8 m-b-8&quot;&gt;          &lt;div v-if=&quot;showSelect&quot; style=&quot;width: 55px&quot; class=&quot;flex ju-center m-r-28&quot;&gt;            &lt;el-checkbox :model-value=&quot;checkAll&quot; :indeterminate=&quot;indeterminate&quot; class=&quot;table-check-all&quot; @change=&quot;handleCheckAll&quot;&gt;&lt;/el-checkbox&gt;          &lt;/div&gt;          &lt;slot name=&quot;batch-action&quot; :selection=&quot;multipleSelection&quot;&gt;            &lt;el-button :disabled=&quot;!multipleSelection?.length&quot; plain type=&quot;danger&quot; @click=&quot;handleBatchDel&quot;&gt;批量删除&lt;/el-button&gt;          &lt;/slot&gt;        &lt;/div&gt;      &lt;/template&gt;    &lt;/el-table&gt;    &lt;el-table v-if=&quot;summaryData?.length&quot; :data=&quot;summaryData&quot; :show-header=&quot;false&quot;&gt;      &lt;el-table-column v-if=&quot;showSelect&quot; width=&quot;55&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column v-if=&quot;showIndex&quot; width=&quot;60&quot;&gt;&lt;/el-table-column&gt;      &lt;slot name=&quot;summary-columns&quot;&gt;        &lt;slot&gt;&lt;/slot&gt;      &lt;/slot&gt;      &lt;template #empty&gt;        &lt;i&gt;&lt;/i&gt;      &lt;/template&gt;    &lt;/el-table&gt;    &lt;div v-show=&quot;data?.length&quot; class=&quot;flex al-center&quot;&gt;      &lt;div v-if=&quot;showSelect &amp;&amp; !headSelect &amp;&amp; ((hideDftCheckAll &amp;&amp; !showBatchDel) || $slots.footer)&quot; style=&quot;width: 55px&quot; class=&quot;flex ju-center m-r-28 m-t-24&quot;&gt;        &lt;el-checkbox :model-value=&quot;checkAll&quot; :indeterminate=&quot;indeterminate&quot; class=&quot;table-check-all&quot; @change=&quot;handleCheckAll&quot;&gt;&lt;/el-checkbox&gt;      &lt;/div&gt;      &lt;div class=&quot;m-t-24&quot;&gt;        &lt;slot name=&quot;footer&quot; :selection=&quot;multipleSelection&quot;&gt;&lt;/slot&gt;      &lt;/div&gt;      &lt;el-pagination        v-if=&quot;showP&quot;        class=&quot;table-pagination m-t-24&quot;        :currentPage=&quot;tableQuery?.pageIndex&quot;        :page-size=&quot;tableQuery?.pageSize&quot;        :page-sizes=&quot;[20, 30, 50, 100, 200]&quot;        layout=&quot;total, sizes, prev, pager, next, jumper&quot;        :total=&quot;total ?? 0&quot;        @size-change=&quot;(v) =&gt; emit(&#39;handleSizeChange&#39;, v)&quot;        @current-change=&quot;(v) =&gt; emit(&#39;handleCurrentChange&#39;, v)&quot;      /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, watch &#125; from &quot;vue&quot;;const props = defineProps(&#123;  tableQuery: &#123; type: Object, default: () =&gt; (&#123; pageIndex: 1, pageSize: 20 &#125;) &#125;,  data: Array,  summaryData: Array,  total: Number,  height: String,  showIndex: &#123; type: Boolean, default: false &#125;, // 是否显示序号列  showSelect: &#123; type: Boolean, default: false &#125;, // 是否显示checkbox  selectDisabled: Function, // 行选项checkbox禁用条件  selectDft: Function, // 行默认选中条件  headSelect: &#123; type: Boolean, default: false &#125;,  hideDftCheckAll: &#123; type: Boolean, default: true &#125;,  showP: &#123;    // 是否显示页码    type: Boolean,    default: true  &#125;,  showBatchDel: &#123; type: Boolean, default: false &#125;, // 是否显示批量删除  loading: &#123; type: Boolean, default: false &#125;,  customEmpty: &#123; type: Boolean, default: true &#125; // 是否显示自定义空数据&#125;);const tableRef = ref();const emit = defineEmits([&quot;handleSizeChange&quot;, &quot;handleCurrentChange&quot;, &quot;handleBatchDel&quot;, &quot;handleSeleted&quot;]);watch(  () =&gt; props.tableQuery,  () =&gt; &#123;    tableRef.value?.setScrollTop(0);  &#125;,  &#123; deep: true &#125;);watch(  () =&gt; props.data,  (val) =&gt; &#123;    if (props.selectDft) &#123;      for (const item of val) &#123;        tableRef.value.toggleRowSelection(item, props.selectDft(item));      &#125;    &#125;  &#125;);const multipleSelection = ref([]);// 多选function handleSelectionChange(val) &#123;  multipleSelection.value = val;  indeterminate.value = val.length &gt; 0 &amp;&amp; val.length &lt; props.data?.length;  checkAll.value = props.data?.length &gt; 0 &amp;&amp; val.length === props.data?.length;  emit(&quot;handleSeleted&quot;, multipleSelection.value);&#125;// 批量删除function handleBatchDel() &#123;  emit(&quot;handleBatchDel&quot;, multipleSelection.value);&#125;// 序号格式化function indexFormat(index, row) &#123;  if (row.rowIndex) &#123;    index = row.rowIndex;  &#125; else if (row.rowIndex === false) &#123;    return &quot;&quot;;  &#125;  const &#123; pageIndex = 1, pageSize = 20 &#125; = props.tableQuery;  return index + 1 + (pageIndex - 1) * pageSize;&#125;const indeterminate = ref(false);const checkAll = ref(false);function handleCheckAll() &#123;  tableRef.value.toggleAllSelection();&#125;// 弄选中状态function transferCheckedStatus(store, row) &#123;  const disabled = props.selectDisabled &amp;&amp; props.selectDisabled(row);  if (disabled &amp;&amp; store?.isSelected(row)) &#123;    store.toggleRowSelection(row);  &#125;  return store?.isSelected(row);&#125;defineExpose(&#123; tableRef, handleCheckAll &#125;);&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.zn-table-content &#123;  height: 100%;  display: flex;  flex: 1;  flex-direction: column;  overflow: auto;  .hide-checkAll &#123;    thead &#123;      .el-table-column--selection &#123;        .el-checkbox &#123;          visibility: hidden;        &#125;      &#125;    &#125;  &#125;  .table-check-all &#123;    position: relative;    &amp;::after &#123;      position: absolute;      content: &quot;全选&quot;;      transform: translateX(calc(50% + 8px));    &#125;  &#125;  .table-pagination &#123;    margin-left: auto;  &#125;  .el-button &#123;    &amp;.is-text &#123;      + .el-button &#123;        margin-left: 0;      &#125;    &#125;  &#125;&#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> element-plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-plus【下拉二次封装-滚动加载】</title>
      <link href="/2023/04/03/element-plus%E3%80%90%E4%B8%8B%E6%8B%89%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85-%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%E3%80%91/"/>
      <url>/2023/04/03/element-plus%E3%80%90%E4%B8%8B%E6%8B%89%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85-%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h3 id="滚动加载-scroll-select-index-vue"><a href="#滚动加载-scroll-select-index-vue" class="headerlink" title="滚动加载 scroll-select/index.vue"></a>滚动加载 scroll-select/index.vue</h3><pre><code>&lt;template&gt;  &lt;el-select ref=&quot;selectRef&quot; :remote-method=&quot;handleSearch&quot; @visible-change=&quot;visibleChange&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/el-select&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &quot;vue&quot;;const props = defineProps(&#123;  loading: Boolean,  diffBottom: &#123;    type: Number,    default: 20  &#125;&#125;);const emit = defineEmits([&quot;loadMore&quot;, &quot;visible-change&quot;, &quot;remote-method&quot;]);const selectRef = ref();let dom, scrollTopLast, cacheKeyword;function handleSearch(value) &#123;  if (!value || cacheKeyword !== value) &#123;    scrollTopLast = undefined;    dom?.scrollTo(&#123; top: 0 &#125;);  &#125;  cacheKeyword = value;  emit(&quot;remote-method&quot;, value);&#125;function visibleChange(visible) &#123;  emit(&quot;visible-change&quot;, visible);  if (visible) &#123;    initScroll();  &#125; else &#123;    dom?.removeEventListener(&quot;scroll&quot;, scrollEvent);  &#125;&#125;function initScroll() &#123;  setTimeout(() =&gt; &#123;    dom = selectRef.value.scrollbar.wrapRef;    const selectedDom = dom.querySelector(&quot;.selected&quot;);    let top = 0;    if (selectedDom) &#123;      top = selectedDom.offsetTop - (dom.offsetHeight - 34);    &#125;    dom?.scrollTo(&#123; top &#125;);    scrollTopLast = undefined;    dom?.addEventListener(&quot;scroll&quot;, scrollEvent);  &#125;, 0);&#125;// eslint-disable-next-line object-curly-spacingfunction scrollEvent(&#123; target: &#123; offsetHeight, scrollHeight, scrollTop &#125; &#125;) &#123;  if (offsetHeight + scrollTop &gt; scrollHeight - props.diffBottom &amp;&amp; !props.loading &amp;&amp; (scrollTopLast === undefined || (scrollTopLast &amp;&amp; scrollTopLast &lt; scrollTop))) &#123;    scrollTopLast = scrollTop;    emit(&quot;loadMore&quot;);  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="基于滚动加载叠加远程搜索-scroll-select-v2-index-vue"><a href="#基于滚动加载叠加远程搜索-scroll-select-v2-index-vue" class="headerlink" title="基于滚动加载叠加远程搜索 scroll-select-v2/index.vue"></a>基于滚动加载叠加远程搜索 scroll-select-v2/index.vue</h3><pre><code>&lt;template&gt;  &lt;scroll-select    :loading=&quot;loading&quot;    :model-value=&quot;currentValue&quot;    loading-text=&quot;加载中...&quot;    no-match-text=&quot;未查询到数据&quot;    no-data-text=&quot;未查询到数据&quot;    clearable    filterable    fit-input-width    remote    reserve-keyword    remote-show-suffix    :allowCreate=&quot;allowCreate&quot;    @remote-method=&quot;handleSearch&quot;    @loadMore=&quot;loadMore&quot;    @clear=&quot;handleClear&quot;    @visible-change=&quot;visibleChange&quot;    @change=&quot;handleChange&quot;    :value-key=&quot;option.key&quot;  &gt;    &lt;slot :options=&quot;listData&quot;&gt;      &lt;el-option v-for=&quot;item in listData&quot; :key=&quot;item[option.key]&quot; :value=&quot;item&quot; :label=&quot;item._label&quot;&gt;        &lt;zy-tooltip :content=&quot;item._label&quot;&gt;&#123;&#123; item._label &#125;&#125;&lt;/zy-tooltip&gt;      &lt;/el-option&gt;    &lt;/slot&gt;  &lt;/scroll-select&gt;&lt;/template&gt;&lt;!-- 提示: 不需要远程搜索功能时，行内透传参数 remote 和 filterable 为 false 即可 --&gt;&lt;script setup name=&quot;scroll-select-v2&quot;&gt;import ScrollSelect from &quot;../scroll-select/index.vue&quot;;import &#123; onMounted, ref, watch &#125; from &quot;vue&quot;;const props = defineProps(&#123;  api: Function,  searchKey: &#123;    // 检索键值    type: String,    default: &quot;name&quot;  &#125;,  formatSearchKey: Function, // 格式化搜索参数  formatDataFc: Function, // 格式化数据的方法  defaultParams: Object, // 默认参数  modelValue: [String, Array],  allowCreate: Boolean,  tooltipPlacement: &#123; type: String, default: &quot;top-start&quot; &#125;,  init: &#123;    // 是否初始化第一页数据    type: Boolean,    default: true  &#125;,  defaultFirst: &#123;    // 是否默认选中第一项    type: Boolean,    default: false  &#125;,  option: &#123;    // option   value【key】及label【label】 的键值    type: Object,    default: () =&gt; (&#123;      key: &quot;id&quot;,      label: &quot;name&quot;    &#125;)  &#125;,  insertList: &#123;    // 回显时，避免浪费接口资源，直接插入要回显的数据    type: Array,    default: () =&gt; []  &#125;,  insertAppend: &#123; type: Boolean, default: false &#125;&#125;);const currentValue = ref(null);function setCurrentValue(v) &#123;  if (isArray(props.modelValue)) &#123;    currentValue.value = cacheListData.filter((item) =&gt; props.modelValue.includes(item[props.option.key]));  &#125; else if (props.modelValue) &#123;    const find = listData.value.find((item) =&gt; &#123;      return item[props.option.key] === v;    &#125;);    if (!find &amp;&amp; props.allowCreate) &#123;      currentValue.value = props.modelValue;    &#125; else &#123;      currentValue.value = find;    &#125;  &#125; else &#123;    currentValue.value = null;  &#125;  if (v !== props.modelValue) &#123;    emit(&quot;change&quot;, currentValue.value);  &#125;&#125;const emit = defineEmits([  &quot;update:modelValue&quot;, // 只给选中项的value值  &quot;update:total&quot;, // 只给选中项的value值  &quot;change&quot;,  &quot;update:data&quot;, // 给选中项的全部json对象  &quot;visibleChange&quot;,  &quot;clear&quot;]);const listData = ref([]);let cacheListData = [...props.insertList.map(formatLabel)],  cacheSearchList = [],  cacheNoMore = false;const listQuery = ref(&#123; pageIndex: 1, pageSize: 20 &#125;);const keyword = ref();let noMore = false;const loading = ref(false);onMounted(() =&gt; &#123;  props.init &amp;&amp; getListData();&#125;);watch(  () =&gt; JSON.stringify(props.defaultParams),  () =&gt; &#123;    reset();  &#125;);watch(  () =&gt; props.insertList,  () =&gt; &#123;    initData();  &#125;);watch(() =&gt; props.modelValue, setCurrentValue);function reset() &#123;  listData.value = [];  cacheListData = [...props.insertList.map(formatLabel)];  keyword.value = undefined;  listQuery.value.pageIndex = 1;  props.init &amp;&amp; getListData();&#125;async function getListData() &#123;  if (!props.api) &#123;    console.warn(&quot;scroll-select-v2 组件 未定义api&quot;);  &#125; else &#123;    loading.value = true;    let query = &#123;      ...props.defaultParams,      ...listQuery.value,      [props.searchKey]: keyword.value    &#125;;    if (props.formatSearchKey) &#123;      query = &#123; ...query, ...props.formatSearchKey(keyword.value) &#125;;    &#125;    let &#123; ok, data, count &#125; = await props.api(query);    loading.value = false;    if (ok) &#123;      emit(&quot;update:total&quot;, count || data?.length || 0);      props.formatDataFc &amp;&amp; data?.length &amp;&amp; (data = props.formatDataFc(data || []));      let temp =        data?.filter((i) =&gt; &#123;          const find = listData.value.find((j) =&gt; j[props.option.key] === i[props.option.key]);          if (!find) &#123;            i._label = formatLabel(i)._label;            if (!cacheListData.find((j) =&gt; j[props.option.key] === i[props.option.key])) &#123;              cacheListData.push(i);            &#125;          &#125;          return !find;        &#125;) || [];      if (keyword.value) &#123;        noMore = ~~data?.length &lt; listQuery.value.pageSize;        cacheSearchList.push(...temp);        listData.value = [...cacheSearchList];      &#125; else &#123;        initData();        cacheNoMore = noMore = ~~data?.length &lt; listQuery.value.pageSize;        if (props.modelValue) &#123;          if (isArray(props.modelValue)) &#123;            const _value = listData.value.filter((item) =&gt; props.modelValue.includes(item[props.option.key]));            if (_value.length &lt; props.modelValue.length) &#123;              loadMore();            &#125;            handleChange(_value);          &#125; else &#123;            const find = listData.value.find((item) =&gt; item[props.option.key] === props.modelValue);            if (find) &#123;              handleChange(find);            &#125; else &#123;              loadMore();            &#125;          &#125;        &#125;        if (!props.modelValue &amp;&amp; props.defaultFirst) &#123;          handleChange(listData.value[0]);        &#125;      &#125;    &#125; else &#123;      noMore = true;    &#125;  &#125;&#125;function loadMore() &#123;  if (!noMore &amp;&amp; !loading.value) &#123;    listQuery.value.pageIndex++;    getListData();  &#125;&#125;function handleSearch(value) &#123;  if (value) &#123;    cacheSearchList = [];    keyword.value = value;    listQuery.value.pageIndex = 1;    listData.value = [];    getListData();  &#125; else &#123;    visibleChange(false);  &#125;&#125;function visibleChange(show) &#123;  if (!props.modelValue) &#123;    if (show) &#123;      initData();      noMore = cacheNoMore;    &#125; else &#123;      keyword.value = undefined;    &#125;  &#125;  if (!show) &#123;    keyword.value = undefined;    initData();    noMore = cacheNoMore;  &#125;  emit(&quot;visibleChange&quot;, show);&#125;function handleClear() &#123;  emit(&quot;clear&quot;);  keyword.value = undefined;  listQuery.value.pageIndex = 1;  initData();  noMore = cacheNoMore;&#125;function initData() &#123;  const temp = cacheListData?.filter((i) =&gt; !props.insertList.find((j) =&gt; j[props.option.key] === i[props.option.key])) || [];  if (props.insertAppend) &#123;    listData.value = [...temp, ...props.insertList.map(formatLabel)];  &#125; else &#123;    listData.value = [...props.insertList.map(formatLabel), ...temp];  &#125;&#125;function handleChange(item) &#123;  let val = item?.[props.option.key];  if (isArray(item)) &#123;    val = item.map((_i) =&gt; _i[props.option.key]);  &#125;  currentValue.value = item;  emit(&quot;update:modelValue&quot;, val);  emit(&quot;update:data&quot;, item);  if (val !== props.modelValue) &#123;    emit(&quot;change&quot;, item);  &#125;&#125;function isArray(obj) &#123;  return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;&#125;function formatLabel(i) &#123;  const _label = props.option.label    .split(&quot;,&quot;)    .map((key) =&gt; i[key])    .filter((i) =&gt; i)    .join(&quot;-&quot;);  return &#123; ...i, _label &#125;;&#125;defineExpose(&#123; reset, initData, setCurrentValue &#125;);&lt;/script&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树形数据筛选</title>
      <link href="/2023/02/01/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%AD%9B%E9%80%89/"/>
      <url>/2023/02/01/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%AD%9B%E9%80%89/</url>
      
        <content type="html"><![CDATA[<pre><code>function fn1(item) &#123;  function temp(&#123; hasChecked, children &#125;) &#123;    return hasChecked || children?.some(temp);  &#125;  return temp(item);&#125;function fn2(arr) &#123;  return arr?.filter(fn1).map((&#123; children, ...o &#125;) =&gt; &#123;    return &#123; ...o, children: fn2(children) &#125;;  &#125;);&#125;const result = fn2(data);      </code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json深层合并</title>
      <link href="/2022/10/08/json%E6%B7%B1%E5%B1%82%E5%90%88%E5%B9%B6/"/>
      <url>/2022/10/08/json%E6%B7%B1%E5%B1%82%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p>export const deepAssign = (…jsonArr) =&gt; {<br>  const temp = {};<br>  jsonArr.forEach(json =&gt; {<br>    Object.keys(json).forEach(key =&gt; {<br>      if (temp[key] !== undefined) {<br>        temp[key] = deepAssign(temp[key], json[key]);<br>      } else {<br>        temp[key] = json[key];<br>      }<br>    });<br>  });<br>  return temp;<br>};</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的js（下卷）</title>
      <link href="/2021/12/08/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89/"/>
      <url>/2021/12/08/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分：起步上路"><a href="#第一部分：起步上路" class="headerlink" title="第一部分：起步上路"></a>第一部分：起步上路</h2><h3 id="第-1-章：深入编程"><a href="#第-1-章：深入编程" class="headerlink" title="第 1 章：深入编程"></a>第 1 章：深入编程</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>程序常被称为源码或代码，它是一组特定的指令，用来指示计算机要执行哪些任务。虽然对 JavaScript 来说可以直接在浏览器的开发者终端中输入代码，但代码通常会被保存在文本文件中。<br>指令的格式和组合规则被称为计算机语言，有时也被称为语法。<br>在计算机语言中，执行特定任务的一组单词、数字和运算符被称为语句。<br>程序就是多个这样语句的集合，它们合起来描述了程序要执行的所有步骤。</p><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>语句由一个或多个表达式组成。一个表达式是对一个变量或值的引用，或者是一组值和变量与运算符的组合。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>在值上执行动作需要运算符。</li><li>执行各种类型的动作需要值和类型，比如，对数字进行数学运算，用字符串输出。</li><li>在程序的执行过程中需要变量来保存数据（也就是状态）。</li><li>需要 if 这样的条件判断来作出决策。</li><li>需要循环来重复任务，直到不满足某个条件。</li><li>需要函数将代码组织为逻辑上可复用的块。</li></ul><p>代码注释是编写可读代码的一种有效方法，能让你的代码更易于理解和维护，如果以后出现问题的话也更加容易进行修复。</p><h3 id="第-2-章：深入-JavaScript"><a href="#第-2-章：深入-JavaScript" class="headerlink" title="第 2 章：深入 JavaScript"></a>第 2 章：深入 JavaScript</h3><h4 id="值与类型"><a href="#值与类型" class="headerlink" title="值与类型"></a>值与类型</h4><ul><li>字符串</li><li>数字</li><li>布尔型</li><li>null 和 undefined</li><li>对象</li><li>符号</li></ul><p>JavaScript 提供了一个 typeof 运算符，该运算符可以用来查看值的类型：</p><pre><code>var a;typeof a; // undefineda=&quot;hello world&quot;;typeof a; // stringa=42;typeof a; // booleana=null;typeof a; // objecta=undefined;typeof a; // undefined;a=&#123;b:&quot;c&quot;&#125;;typeof a; // object</code></pre><p>typeof 运算符的返回值永远是这 6 个（对 ES6 来说是 7 个）字符串值之一。也就是说，typeof “abc” 返回 “string”,而不是 string。</p><p>1、对象<br>对象类型是指一个组合值，你可以为其设置属性（命名的位置），每个属性可以持有属于自己的任意类型的值。</p><ol><li>数组<br>数组是一个持有（任意类型）值的对象，这些值不是通过命名属性/键值索引，而是通过数字索引位置</li><li>函数<br>函数也同样是对象的一个子类型，因为 typeof 返回”function”，这意味着 function 是一个主类型，因此，function 可以拥有属性，但通常只在很少的情况下才会使用函数的对象属性</li></ol><p>2、内置类型方法<br>字符串值可以封装未 String 对象，数字可以封装为 Number 对象，布尔型值可以封装为 Boolean 对象。在多数情况下，不需要思考直接使用这样的值的对象封装形式，所有情况下都使用原生值形式，让 JavaScript 负责其余的事情。</p><p>3、值的比较</p><ol><li>类型转换</li><li>真与假</li><li>相等<br>相等运算符有四种：==、===、!=和!==。!形式显然是相应的“不等”版本；不要混淆了不等关系和不相等。<br>==和===的区别在于，==检查的是允许类型转换情况下的值的相等性，而===检查不允许类型转换情况下的值的相等性；因此，===经常被称为“严格相等”。<br>==的粗略相等比较允许隐式的类型转换，而严格相等比较===则不允许：</li><li>不等关系<br>运算符&lt;,&gt;、&lt;=和&gt;=用于表示不等关系。</li></ol><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在 JavaScript 中，变量的名称（包括函数名称）必须是有效的标识符。考虑到 Unicode 这样的非传统字符的情况，标识符中有效字符的严格完整规则有点复杂。如果只是考虑常用的 ASCII 字母数字的话，那么规则是非常简单的。<br>标识符必须有 a<del>z、A</del>Z、$或_开始。它可以包含前面所有这些字符以及数字 0-9。</p><h5 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h5><p>如果使用关键字 var 声明一个变量，那么这个变量就属于当前的函数作用域，如果声明是发生在任何函数外的顶层声明，那么这个变量则属于全局作用域。</p><ol><li>提升</li></ol><p>无论 var 出现在一个作用域中的哪个位置，这个声明都属于整个作用域，在其中到处都是可以访问的。</p><p>这一行为被比喻地称为提升，var 声明概念上“移动”到了其所在作用域的最前面</p><ol start="2"><li>嵌套作用域<br>声明后的变量在这个作用域内是随处可以访问的，包括所有低层/内层的作用域。</li></ol><p>除了在函数层级声明变量，ES6 还支持通过 let 关键字声明属于单独快（{…}对）的变量。块作用域非常有助于更细化地管理变量作用域，从而更容易随着时间的发展而维护代码。</p><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>1、立即调用函数表达式</p><pre><code>  (function IIFE()&#123;     console.log(&#39;Hi);  &#125;)();</code></pre><p>(function IIFE(){…})函数表达式外面的(…)就是 JavaScript 语法能够防止其成为普通函数声明的部分。<br>表达式最后的()实际上就表示立即执行前面给出的函数表达式。</p><p>2、闭包<br>闭包是 JavaScript 中一个非常重要，且经常被误解的概念。</p><h4 id="this-标识符"><a href="#this-标识符" class="headerlink" title="this 标识符"></a>this 标识符</h4><p>如果一个函数内部有一个 this 引用，那么这个 this 通常指向一个对象。但它指向的是哪个对象要根据这个函数是如何被调用来决定。</p><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>当引用对象的某个属性时，如果这个属性并不存在，那么 JavaScript 会自动使用对象的内部原型引用找到另外一个对象来寻找这个属性。</p><p>从一个对象到其后备对象的内部原型引用的链接是在创建对象时发生的。展示这一点的最简单的方法就是使用内置工具 Object.create(…)。</p><h4 id="旧与新"><a href="#旧与新" class="headerlink" title="旧与新"></a>旧与新</h4><p>1、polyfilling<br>用于表示根据新特性的定义，创建一段与之行为等价但能够在旧的 JavaScript 环境中运行的代码。<br>2、transpiling<br>通过工具将新版代码转换为等价的旧版代码。这个过程通常被称为“transpiling”。它是由 transforming（转换）和 compiling（编译）组合而成的术语。</p><h4 id="非-JavaScript"><a href="#非-JavaScript" class="headerlink" title="非 JavaScript"></a>非 JavaScript</h4><h5 id="DOM-API"><a href="#DOM-API" class="headerlink" title="DOM API"></a>DOM API</h5><p>当代码在浏览器中运行时，变量 document 作为一个全局变量存在。它既不是由 JavaScript 引擎提供的，也不由 JavaScript 标准控制。它是一个特殊的对象，通常被称为“宿主对象”。</p><h5 id="输入-输出（I-O）。"><a href="#输入-输出（I-O）。" class="headerlink" title="输入/输出（I/O）。"></a>输入/输出（I/O）。</h5><p>浏览器提供了 alert(…)、console.log(…)…等。</p><h3 id="第-3-章：深入“你不知道的-JavaScript”系列"><a href="#第-3-章：深入“你不知道的-JavaScript”系列" class="headerlink" title="第 3 章：深入“你不知道的 JavaScript”系列"></a>第 3 章：深入“你不知道的 JavaScript”系列</h3><h4 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h4><h4 id="this-和对象原型"><a href="#this-和对象原型" class="headerlink" title="this 和对象原型"></a>this 和对象原型</h4><h4 id="类型和语法"><a href="#类型和语法" class="headerlink" title="类型和语法"></a>类型和语法</h4><h4 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h4><h4 id="ES6-及更新版本"><a href="#ES6-及更新版本" class="headerlink" title="ES6 及更新版本"></a>ES6 及更新版本</h4><h2 id="第二部分：ES6-及更新版本"><a href="#第二部分：ES6-及更新版本" class="headerlink" title="第二部分：ES6 及更新版本"></a>第二部分：ES6 及更新版本</h2><h3 id="第-1-章：ES？现在与未来"><a href="#第-1-章：ES？现在与未来" class="headerlink" title="第 1 章：ES？现在与未来"></a>第 1 章：ES？现在与未来</h3><h3 id="第-2-章：语法"><a href="#第-2-章：语法" class="headerlink" title="第 2 章：语法"></a>第 2 章：语法</h3><p>1、块作用域声明</p><ol><li>let 声明</li><li>const 声明</li><li>块作用域函数</li></ol><p>2、spread/rest<br>ES6 引入了一个新的运算符…，通常称为 spread 或 rest（展开或收集）运算符，取决于它在哪/如何使用</p><p>3、默认参数值<br>函数默认值可以不只是简单值；它们可以是任意合法表达式，甚至是函数调用。</p><p>4、解构<br>ES6 为解构新增了一个专门语法，专用于数组解构和对象解构。</p><ol><li>对象属性赋值模式</li><li>不只是声明<br>如果省略了 var/let/const 声明符，就必须把整个赋值表达式用()括起来。如果不这样做，语句左侧{…}作为语句中的第一个元素就会被当做是一个块语句而不是一个对象。</li></ol><p>举例来说：</p><pre><code>  [a,b,c]=[1,2,3]  (&#123;x,y,z&#125;)=&#123;x:4,y:5,z:6&#125;</code></pre><p>实际上，赋值表达式并不必须是变量标识符。任何合法的赋值表达式都可以。<br>举例来说：</p><pre><code>  var o = &#123;&#125;;  [o.a, o.b, o.c]= [1, 2, 3]  (&#123;o.x,o.y,o.z&#125;)=&#123;x:4,y:5,z:6&#125;</code></pre><ol start="3"><li>重复赋值</li></ol><p>5、</p><ol><li>默认值赋值</li></ol><p>例：</p><pre><code>  var [a=3,b=6]=[1,2]  var &#123;x=5,y=6&#125;=&#123;x:1,y:2&#125;</code></pre><p>可以组合使用默认值赋值和赋值表达式语法</p><pre><code>  var &#123;x, y, z: ZZ = 20&#125; = &#123;x:1, y:2 &#125;  console.log(x, y, WW) // 1 2 20</code></pre><ol start="2"><li>嵌套解构<br>如果解构的值中有嵌套的对象或者数组，也可以解构这些嵌套的值</li></ol><p>例：</p><pre><code>  var a1 = [1, [2, 3, 4], 5]  var 01 = &#123; x: &#123; y : &#123; z: 6&#125; &#125; &#125;  var [a, [b, c, d], e ]=a1;  var &#123; x: &#123;y : &#123; z: w&#125;&#125;&#125;=o1;  console.log( a, b, c, d, e);  // 1 2 3 4 5  console.log( w )              // 6</code></pre><ol start="3"><li>解构参数</li></ol><h4 id="对象字面量扩展"><a href="#对象字面量扩展" class="headerlink" title="对象字面量扩展"></a>对象字面量扩展</h4><p>1、简洁属性<br>2、简洁方法<br>3、计算属性名<br>4、设定[[Protottype]]<br>要为已经存在的对象设定[[Prototype]]，可以使用 ES6 工具 Object.setPrototypeOf(obja,objb)<br>5、super 对象</p><h4 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h4><pre><code>  `$&#123;...&#125;`</code></pre><ol><li><p>插入表达式<br> ${…}内可以出现任何合法的表达式，包括函数调用、在线函数表达式调用，甚至其他插入字符串字面量。</p></li><li><p>标签模板字面量</p><p> 例：</p><pre><code>   function foo(strings,...vakues)&#123;      console.log(strubgs);      console.log(values);   &#125;   var desc = &quot;awesome&quot;;   foo`Everything is $&#123;desc&#125;!`;   // [&quot;Everything is &quot;, &quot;!&quot;];   // [&quot;awesome&quot;];</code></pre></li></ol><p>本质上说，这是一类不需要(…)的特殊函数调用。但是传入为了字符串字面量作为标签被调用的 foo(..)函数的是什么？<br>第一个参数，名为 strings，是一个由所有普通字符串组成的数组。<br>收集到 values 数组的参数是已经求值的在字符串字面值中插入表达式的结果。</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><h4 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h4><p>for…of 循环，在迭代器产生的一系列值上循环。在低层，for…of 循环向 iterable 请求一个迭代器（通过内建的 Symbol.iterator），然后反复调用这个迭代器把它产生的值赋给循环迭代变量。<br>JavaScript 中默认为（或提供）iterable 的标准内建值包括：</p><ul><li>Arrays</li><li>Strings</li><li>Generators</li><li>Collections/TypedArrays</li></ul><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h4 id="数字字面量扩展"><a href="#数字字面量扩展" class="headerlink" title="数字字面量扩展"></a>数字字面量扩展</h4><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode 字符范围从 0x0000 到 0xFFFF，包含可能看到和接触到的所有（各种语言的）标准打印字符。这组字符称为基本多语言平面。</p><h3 id="第-3-章：代码组织"><a href="#第-3-章：代码组织" class="headerlink" title="第 3 章：代码组织"></a>第 3 章：代码组织</h3><h3 id="第-4-章：异步流控制"><a href="#第-4-章：异步流控制" class="headerlink" title="第 4 章：异步流控制"></a>第 4 章：异步流控制</h3><h3 id="第-5-章：集合"><a href="#第-5-章：集合" class="headerlink" title="第 5 章：集合"></a>第 5 章：集合</h3><h3 id="第-6-章：新增-API"><a href="#第-6-章：新增-API" class="headerlink" title="第 6 章：新增 API"></a>第 6 章：新增 API</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>1、静态函数 Array.of(…)<br>2、静态函数 Array.from(…)<br>3、创建数组和子类型<br>4、原型方法 copyWithin(…)<br>5、原型方法 fill(…)<br>6、原型方法 find(…)<br>7、原型方法 findIndex(…)<br>8、原型方法 entries()、values()、keys()</p><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>1、静态函数 Object.is(…)<br>2、静态函数 Object.getOwnPropertySymbols(…)<br>3、静态函数 Object.setPrototypeOf(…)<br>4、静态函数 Object.assign(…)</p><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>1、三角函数</p><ol><li>cosh(…) 双曲余弦函数</li><li>acosh(…) 双曲反余弦函数</li><li>sinh(…) 双曲正弦函数</li><li>asinh(…) 双曲反正弦函数</li><li>tanh(…) 双曲正切函数</li><li>atanh(…) 双曲反正切函数</li><li>hypot(…) 平方和的平方根（广义勾股定理）</li></ol><p>2、算数</p><ol><li>cbrt(…) 立方根</li><li>clz32(…) 计算 32 位二进制表示的前导 0 个数</li><li>expm1(…) 等价于 exp(x) - 1</li><li>log2(…) 二进制对数（以 2 为底的对数）</li><li>log10(…) 以 10 为底的对数</li><li>log1p(…) 等价于 log(x + 1)</li><li>imul(…) 两个数字的 32 位整数乘法</li></ol><p>3、元工具</p><ol><li>sign(…) 返回数字符号</li><li>trunc(…) 返回数字的整数部分</li><li>fround(…) 向最接近的 32 位（单精度）浮点值取整</li></ol><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>1、静态属性</p><ol><li>Number.EPSILON 任意两个值之间的最小差：2^ - 52</li><li>Number.MAX_SAFE_INTEGER JavaScript 可以用数字值无歧义“安全”表达的最大整数：2^53 - 1</li><li>Number.MIN_SAFE_INTEGER JavaScript 可以用数字值无歧义“安全”表达的最小整数：-(2^53 - 1) 或 (-2)^53 + 1</li></ol><p>2、静态函数 Number.isNaN(…)<br>3、静态函数 Number.isFinite(…)<br>标准的全局 isFinite(…)会对参数进行强制类型转换，但是 Number.isFinite(…)会略去这种强制行为<br>4、整型相关静态函数</p><ol><li>Number.isInteger(…)</li><li>Number.isSafeInteger(…)</li></ol><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>1、Unicode 函数<br>2、静态函数 String.raw(…)<br>3、原型函数 repeat(…)<br>4、字符串检查函数</p><ol><li>startsWith(…)</li><li>endsWith(…)</li><li>includes(…)</li></ol><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>Array 新增了静态函数 of(…)和 from(…)，以及像 copyWithin(…)和 fill(…)这样的原型函数。</li><li>Object 新增了静态函数 is(…)和 assign(…)。</li><li>Math 新增了静态函数 acosh(…)和 clz32(…)。</li><li>Number 新增了静态属性 Number.EPSILON，以及静态函数 Number.isFinite(…)。</li><li>String 新增了静态函数 String.fromCodePoint(…)和 String.raw(…)，以及原型函数 repeat(…)和 includes(…)。</li></ul><h3 id="第-7-章：元编程"><a href="#第-7-章：元编程" class="headerlink" title="第 7 章：元编程"></a>第 7 章：元编程</h3><h4 id="函数名称"><a href="#函数名称" class="headerlink" title="函数名称"></a>函数名称</h4><h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><h4 id="公开符号"><a href="#公开符号" class="headerlink" title="公开符号"></a>公开符号</h4><p>1、Symbol.iterator<br>2、Symbol.toStringTag 与 Symbol.hasInstance<br>3、Symbol.species<br>4、Symbol.toPrimitive<br>5、正则表达式符号<br>6、Symbol.isConcatSpreadable<br>7、Symbol.unscopables</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>get(…)<br>set(…)<br>deleteProperty(…)<br>apply(…)<br>construct(…)<br>getOwnPropertyDescriptor(…)<br>defineProperty(…)<br>getPrototypeOf(…)<br>setPrototypeOf(…)<br>preventExtensions(…)<br>isExtensible(…)<br>ownKeys(…)<br>enumerate(…)<br>has(…)<br>1、代理局限性<br>2、可取消代理<br>3、使用代理</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>元编程是指把程序的逻辑转向关注自身（或自身的运行时环境），要么是为了查看自己的解构，要么是为了修改它。元编程的主要价值是扩展语言的一般机制来提供额外的新功能。<br>在 ES6 之前，JavaScript 已经有了不少的元编程功能，而 ES6 提供了几个新特性，显著提高了元编程能力。<br>从匿名函数的函数名推导，到提供了构造器调用方式这样的信息的元属性，你可以比过去更深入地查看程序运行时的结构。通过公开符号可以覆盖原本特性，比如对象到原生类型的类型转换。代理可以拦截并自定义对象的各种底层操作，Reflect 提供了工具来模拟它们。<br>特性测试，甚至可以测试像尾递归优化这样微妙的语义特性，把元编程的焦点从你的程序转移到 JavaScript 引擎功能本身。通过更多地了解环境能力，你的程序可以在运行时调整自己达到最优效果。</p><h3 id="第-8-章：ES6-之后"><a href="#第-8-章：ES6-之后" class="headerlink" title="第 8 章：ES6 之后"></a>第 8 章：ES6 之后</h3>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的js（中卷）</title>
      <link href="/2021/09/06/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89/"/>
      <url>/2021/09/06/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分：类型和语法"><a href="#第一部分：类型和语法" class="headerlink" title="第一部分：类型和语法"></a>第一部分：类型和语法</h2><h3 id="第-1-章：类型"><a href="#第-1-章：类型" class="headerlink" title="第 1 章：类型"></a>第 1 章：类型</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>JavaScript 有七种内置类型：</p><ul><li>空值（null）</li><li>未定义（undefined）</li><li>布尔值（boolean）</li><li>数字（number）</li><li>字符串（string）</li><li>对象（object）</li><li>符号（symbol，ES6 中新增）</li></ul><p>除对象之外，其他统称为“基本类型”。<br>null 是基本类型中唯一的一个“假值”（falsy 或者 false-like，参见第 4 章）类型，typeof 对它的返回值为”object”</p><pre><code>typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;; // true</code></pre><p>function（函数）实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性[[Call]]，该属性使其可以被调用。</p><p>函数不仅是对象，还可以拥有属性。例如：</p><pre><code>function a(b,c) &#123;    /* .. */&#125;</code></pre><p>函数对象的 length 属性是其声明的参数的个数：</p><pre><code>a.length; // 2</code></pre><p>因为该函数声明了两个命名参数，b 和 c，所以其 length 值为 2。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 有七种内置类型：null、undefined、boolean、number、string、object 和 symbol，可以使用 typeof 运算符来查看。<br>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。<br>很多开发人员将 undefined 和 undeclared 混为一谈，但在 JavaScript 中它们是两码事。undefined 是值的一种。undeclared 则表示变量还没有被声明过。<br>遗憾的是，JavaScript 却将它们混为一谈，在我们试图访问“undeclared”变量时这样报错：ReferenceError：a is not defined，并且 typeof 对 undefined 和 undeclared 变量都返回“undefined”。<br>然而，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的办法。</p><h3 id="第-2-章：值"><a href="#第-2-章：值" class="headerlink" title="第 2 章：值"></a>第 2 章：值</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><pre><code>    Number.parseFloat()     //将字符串转换成浮点数，和全局方法 parseFloat() 作用一致。    Number.parseInt()       //将字符串转换成整型数字，和全局方法 parseInt() 作用一致。    Number.isFinite()       //判断传递的参数是否为有限数字。    Number.isInteger()      //判断传递的参数是否为整数。    Number.isNaN()          //判断传递的参数是否为 isNaN()。    Number.isSafeInteger()  //判断传递的参数是否为安全整数。    toExponential()         //返回一个数字的指数形式的字符串，如：1.23e+2    toFixed()                //返回指定小数位数的表示形式。    toPrecision()           //返回一个指定精度的数字</code></pre><h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><p>1、不是值的值<br>undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名称既是类型也是值。<br>undefined 和 null 常被用来表示“空的”值或“不是值”的值。二者之间有一些细微的差别。例如：</p><ul><li>null 指空值（empty value）</li><li>undefined 指没有值（missing value）</li></ul><p>或者：</p><ul><li>undefined 指从未赋值</li><li>null 指曾赋过值，但是目前没有值</li></ul><p>null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。<br>2、undefined<br>3、特殊的数字</p><ol><li><p>不是数字的数字<br> Number.isNaN(..)</p></li><li><p>无穷数<br> Infinity<br> 1/0 = Infinity<br> 1/-0 = -Infinity</p></li><li><p>零值<br> 区分-0 和 0，不能仅仅依赖开发调试窗口的显示结果，还需要做一些特殊处理：</p><pre><code>  function isNegZero(n) &#123;      n = Number( n );      return (n === 0) &amp;&amp; (1 / n === -Infinity);  &#125;  isNegZero( -0 );        // true  isNegZero( 0 / -3 );    // true  isNegZero( 0 );         // false</code></pre></li><li><p>特殊等式<br> ES6 中新加入了一个工具方法 Object.is(..)来判断两个值是否绝对相等(主要用来处理那些特殊的相等比较)</p></li></ol><h4 id="值和引用"><a href="#值和引用" class="headerlink" title="值和引用"></a>值和引用</h4><p>JavaScript 中没有指针，引用的工作机制也不尽相同。在 JavaScript 中变量不可能成为指向另一个变量的引用。<br>JavaScript 引用指向的是值。如果一个值有 10 个引用，这些引用指向的都是同一个值，它们相互之间没有引用/指向关系。</p><p>简单值（即标量基本类型值，scalar primitive）总是通过值复制的方式来赋值/传递，包括 null、undefined、字符串、数字、布尔和 ES6 中的 symbol。<br>复合值（compound value）——对象（包括数组和封装对象，参见第 3 章）和函数，则总是通过引用复制的方式来赋值/传递。</p><h3 id="第-3-章：原生函数"><a href="#第-3-章：原生函数" class="headerlink" title="第 3 章：原生函数"></a>第 3 章：原生函数</h3><p>常用的原生函数有：</p><ul><li>String()</li><li>Number()</li><li>Boolean()</li><li>Array()</li><li>Object()</li><li>Function()</li><li>RegExp()</li><li>Date()</li><li>Error()</li><li>Symbol()</li></ul><p>new String(“abc”)创建的是字符串”abc”的封装对象，而非基本类型值”abc”。</p><h4 id="内部属性-Class"><a href="#内部属性-Class" class="headerlink" title="内部属性[[Class]]"></a>内部属性[[Class]]</h4><p>所有 typeof 返回值为”object”的对象（如数组）都包含一个内部属性[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..)来查看。</p><h4 id="封装对象包装"><a href="#封装对象包装" class="headerlink" title="封装对象包装"></a>封装对象包装</h4><p>一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript 引擎自己决定什么时候应该使用封装对象。换句话说，就是应该优先考虑使用”abc”和 42 这样的基本类型值，而非 new String(“abc”)和 new Number(42)。</p><h5 id="封装对象释疑"><a href="#封装对象释疑" class="headerlink" title="封装对象释疑"></a>封装对象释疑</h5><pre><code>    a = new Boolean( true );    a === true // false    b = Boolean( true );    b === true // true</code></pre><h4 id="拆封"><a href="#拆封" class="headerlink" title="拆封"></a>拆封</h4><p>如果想要得到封装对象中的基本类型值，可以使用 valueOf()函数</p><pre><code>    var a = new String( &quot;abc&quot; );    var b = new Number( 42 );    var c = new Boolean( true );    a.valueOf(); // &quot;abc&quot;    b.valueOf(); // 42    c.valueOf(); // true    // 或隐式拆封（强制类型转换）    var a = new String( &quot;abc&quot; );    var b = a + &quot;&quot;; // b的值为&quot;abc&quot;    typeof a;       // &quot;object&quot;    typeof b;       // &quot;string&quot;</code></pre><h4 id="原生函数作为构造函数"><a href="#原生函数作为构造函数" class="headerlink" title="原生函数作为构造函数"></a>原生函数作为构造函数</h4><p>关于数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常量的形式来创建它们。实际上，使用常量和使用构造函数的效果是一样的（创建的值都是通过封装对象来包装）。<br>如前所述，应该尽量避免使用构造函数，除非十分必要，因为它们经常会产生意想不到的结果。</p><p>1、Array(…)<br>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length）， 而非只充当数组中的一个元素。Array.apply(null,{length:3})比 Array(3)更准确可靠<br>2、Object(…)、Function(…)和 RegExp(…)<br>同样，除非万不得已，否则尽量不要使用 Object(..)/Function(..)/RegExp(..)：<br>3、Date(…)和 Error(…)<br>创建日期对象必须使用 new Date()。Date(..)可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间。<br>构造函数 Error(..)（与前面的 Array()类似）带不带 new 关键字都可。创建错误对象（error object）主要是为了获得当前运行栈的上下文（大部分 JavaScript 引擎通过只读属性.stack 来访问）。栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试（debug）。<br>4、Symbol(…)<br>ES6 中新加入了一个基本数据类型——符号（Symbol）。符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。</p><pre><code>    const a = Symbol(&#39;a&#39;)    const b = Symbol(&#39;a&#39;)    const c = &#123;[a]: &#39;aaa&#39;,[b]: &#39;bbb&#39;&#125;    console.log(c) // &#123;Symbol(a): &quot;aaa&quot;, Symbol(a): &quot;bbb&quot;&#125;</code></pre><p>符号并非对象，而是一种简单标量基本类型。<br>5、原生原型</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 为基本数据类型值提供了封装对象，成为原生函数（如 String、Number、Boolean 等）。它们为基本数据类型值提供了该子类型所特有的方法和属性。<br>对于简单标量基本类型值，比如”abc”,如果要访问它的 length 属性或 string.prototype 方法，JavaScript 引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实现对这些属性和方法的访问。</p><h3 id="第-4-章：强制类型转换"><a href="#第-4-章：强制类型转换" class="headerlink" title="第 4 章：强制类型转换"></a>第 4 章：强制类型转换</h3><h4 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h4><p>将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。<br>类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时。在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。<br>使用 Object.create(null)创建的对象[[Prototype]]属性为 null，并且没有 valueOf()和 toString()方法，因此无法进行强制类型转换。</p><h4 id="抽象值操作"><a href="#抽象值操作" class="headerlink" title="抽象值操作"></a>抽象值操作</h4><p>1、ToString<br>基本类型值的字符串化规则为：null 转换为”null”，undefined 转换为”undefined”，true 转换为”true”。NaN 为’NaN’<br>对普通对象来说，除非自行定义，否则 toString()（Object.prototype.toString()）返回内部属性[[Class]]的值<br>数组的默认 toString()方法经过了重新定义，将所有单元字符串化以后再用”,”连接起来：</p><pre><code>    var a = [1,2,3];    a.toString(); // &quot;1,2,3&quot;</code></pre><p>toString()可以被显式调用，或者在需要字符串化时自动调用。</p><h5 id="JSON-字符串化-工具函数-JSON-stringify-在将-JSON-对象序列化为字符串时也用到了-ToString。"><a href="#JSON-字符串化-工具函数-JSON-stringify-在将-JSON-对象序列化为字符串时也用到了-ToString。" class="headerlink" title="JSON 字符串化(工具函数 JSON.stringify(..)在将 JSON 对象序列化为字符串时也用到了 ToString。)"></a>JSON 字符串化(工具函数 JSON.stringify(..)在将 JSON 对象序列化为字符串时也用到了 ToString。)</h5><h5 id="所有安全的-JSON-值（JSON-safe）都可以使用-JSON-stringify-字符串化。安全的-JSON-值是指能够呈现为有效-JSON-格式的值。JSON-stringify-在对象中遇到-undefined、function-和-symbol-时会自动将其忽略，在数组中则会返回-null（以保证单元位置不变）。"><a href="#所有安全的-JSON-值（JSON-safe）都可以使用-JSON-stringify-字符串化。安全的-JSON-值是指能够呈现为有效-JSON-格式的值。JSON-stringify-在对象中遇到-undefined、function-和-symbol-时会自动将其忽略，在数组中则会返回-null（以保证单元位置不变）。" class="headerlink" title="所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..)字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。JSON.stringify(..)在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。"></a>所有安全的 JSON 值（JSON-safe）都可以使用 JSON.stringify(..)字符串化。安全的 JSON 值是指能够呈现为有效 JSON 格式的值。JSON.stringify(..)在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。</h5><p>2、ToNumber<br>其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p><p>3、ToBoolean</p><ol><li>假值<br>JavaScript 中的值可以分为以下两类：<br>(1) 可以被强制类型转换为 false 的值<br>(2) 其他（被强制类型转换为 true 的值）</li><li>假值对象<br>Boolean(new Boolean(false)) // true<br>Boolean(new Boolean(0)) // true<br>Boolean(new Boolean(‘’)) // true<br>Boolean(document.all) // false</li><li>真值<br>真值就是假值列表之外的值。</li></ol><h4 id="显式强制类型转换"><a href="#显式强制类型转换" class="headerlink" title="显式强制类型转换"></a>显式强制类型转换</h4><p>1、字符串和数字之间的显示转换</p><ol><li>日期显示转换为数字</li></ol><p>+new Date(‘Sun Dec 12 2021 17:31:00 GMT+0800 (中国标准时间)’) // 1639301464548<br>不建议对日期类型使用强制类型转换，应该使用 Date.now()来获得当前的时间戳，使用 new Date(..).getTime()来获得指定时间的时间戳。</p><ol start="2"><li><p>奇特的~运算符<br>它首先将值强制类型转换为 32 位数字，然后执行字位操作“非”（对每一个字位进行反转）。<br>if (~a.indexOf(..))仍然是对 indexOf(..)的返回结果进行隐式强制类型转换，0 转换为 false，其他情况转换为 true。但我觉得~更像显式强制类型转换，前提是我对它有充分的理解。<br>~比&gt;= 0 和=== -1 更简洁。</p></li><li><p>字位截除<br>一些开发人员使用~~来截除数字值的小数部分，以为这和 Math.floor(..)的效果一样，实际上并非如此。<br>~~中的第一个~执行 ToInt32 并反转字位，然后第二个~再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。<br>对~~我们要多加注意。首先它只适用于 32 位数字，更重要的是它对负数的处理与 Math.floor(..)不同。</p><p>Math.floor( -49.6 ); // -50<br>~~-49.6; // -49</p></li></ol><p>~~x 能将值截除为一个 32 位整数，x | 0 也可以，而且看起来还更简洁。出于对运算符优先级的考虑，我们可能更倾向于使用~~x：</p><p>2、显式解析数字字符串<br>parseInt(..)针对的是字符串值。向 parseInt(..)传递数字和其他类型的参数是没有用的<br>parseInt(1/0, 19)实际上是 parseInt(“Infinity”, 19)。第一个字符是”I”，以 19 为基数时值为 18。第二个字符”n”不是一个有效的数字字符，解析到此为止，和”42px”中的”p”一样。</p><p>3、显式转换为布尔值<br>使用 Boolean(a)和!!a 来进行显式强制类型转换。</p><h4 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h4><p>1、隐式的简化<br>2、字符串和数字之间的隐式强制类型转换<br>3、布尔值到数字的隐式强制类型转换<br>4、隐式强制类型转换为布尔值<br>相对布尔值，数字和字符串操作中的隐式强制类型转换还算比较明显。下面的情况会发生<br>布尔值隐式强制类型转换。<br>(1) if (..) 语句中的条件判断表达式。<br>(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。<br>(3) while (..) 和 do..while(..) 循环中的条件判断表达式。<br>(4) ? : 中的条件判断表达式。<br>(5) 逻辑运算符 ||（逻辑或）和   （逻辑与）左边的操作数（作为条件判断表达式）。<br>5、||和&amp;&amp;<br>6、符号的强制类型转换<br>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换<br>为布尔值（显式和隐式结果都是 true）。</p><h4 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h4><p>宽松相等（loose equals）== 和严格相等（strict equals）=== 都用来判断两个值是否“相<br>等”<br>常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。听起来蛮有道理，然而<br>还不够准确。很多 JavaScript 的书籍和博客也是这样来解释的，但是很遗憾他们都错了。<br>== 允许在相等比较中进行强制类型转换，而 === 不允许<br>1、相等比较操作的性能<br>如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎<br>实现上的细微差别之外，它们之间并没有什么不同。<br>如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 ==，没有就用 ===，不用在乎性能。<br>2、抽象相等<br>ES5 规范 11.9.3 节的“抽象相等比较算法”定义了 == 运算符的行为。</p><ol><li><p>字符串和数字之间的相等比较<br> 字符串被强制类型转换为数字以便进行相等比较</p></li><li><p>其他类型和布尔类型之间的相等比较<br> == 两边的布尔值会被强制类型转换为数字。</p></li><li><p>null 和 undefined 之间的相等比较<br> 在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换</p></li><li><p>对象和非对象之间的相等比较<br> (1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；<br> (2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p></li><li><p>比较少见的情况</p><ol><li><p>返回其他数字</p><pre><code>  Number.prototype.valueOf = function() &#123;     return 3;  &#125;;  new Number( 2 ) == 3; // true</code></pre></li><li><p>假值的相等比较</p><pre><code> &quot;0&quot; == null; // false &quot;0&quot; == undefined; // false &quot;0&quot; == false; // true &quot;0&quot; == NaN; // false &quot;0&quot; == 0; // true &quot;0&quot; == &quot;&quot;; // false false == null; // false false == undefined; // false false == NaN; // false false == 0; // true false == &quot;&quot;; // true false == []; // true false == &#123;&#125;; // false &quot;&quot; == null; // false &quot;&quot; == undefined; // false &quot;&quot; == NaN; // false &quot;&quot; == 0; // true &quot;&quot; == []; // true &quot;&quot; == &#123;&#125;; // false 0 == null; // false 0 == undefined; // false 0 == NaN; // false 0 == []; // true 0 == &#123;&#125;; // false</code></pre></li><li><p>极端情况</p><pre><code> [] == ![] // true [] == []  // false [] === [] // false 2 == [2]; // true &quot;&quot; == [null]; // true 0 == &quot;\n&quot;; // true</code></pre></li><li><p>完整性检查</p><pre><code> &quot;0&quot; == false; // true false == 0; // true false == &quot;&quot;; // true false == []; // true &quot;&quot; == 0; // true &quot;&quot; == []; // true 0 == []; // true &quot;&quot; == 0; // true &quot;&quot; == []; // true 0 == []; // true</code></pre></li><li><p>安全运用隐式强制类型转换</p><ul><li><p>如果两边的值中有 true 或者 false，千万不要使用 ==。</p></li><li><p>如果两边的值中有 []、”” 或者 0，尽量不要使用 ==。</p><p>这时最好用 === 来避免不经意的强制类型转换。</p></li></ul></li></ol></li></ol><h4 id="抽象关系比较"><a href="#抽象关系比较" class="headerlink" title="抽象关系比较"></a>抽象关系比较</h4><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>强制类型转换包括显式和隐式<br>强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为有使命感的 JavaScript 开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。<br>显式强制类型转换明确告诉我们哪里发生了类型转换，有助于提高代码可读性和可维护性。<br>隐式强制类型转换则没有那么明显，是其他操作的副作用。感觉上好像是显式强制类型转换的反面，实际上隐式强制类型转换也有助于提高代码的可读性。<br>在处理强制类型转换的时候要十分小心，尤其是隐式强制类型转换。在编码的时候，要知其然，还要知其所以然，并努力让代码清晰易读。</p><h3 id="第-5-章：语法"><a href="#第-5-章：语法" class="headerlink" title="第 5 章：语法"></a>第 5 章：语法</h3><h4 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h4><p>语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词。<br>1、语句的结果值<br>虽然目前语句的结果值还无关紧要，但随着 JavaScript 语言的演进，它可能会扮演越来越<br>重要的角色。<br>2、表达式的副作用</p><pre><code>    var a = 42;    var b = a++;</code></pre><p>a++ 首先返回变量 a 的当前值 42（再将该值赋给 b），然后将 a 的值加 1：</p><pre><code>    var a = 42;    var b = a++;    a; // 43    b; // 42</code></pre><p>++ 在前面时，如 ++a，它的副作用（将 a 递增）产生在表达式返回结果值之前，而 a++ 的<br>副作用则产生在之后。<br>可以使用 , 语句系列逗号运算符（statement-series comma operator）将语法多个独立的表达式语句串联成一个语句：</p><pre><code>    var a = 42, b;    b = ( a++, a );    a; // 43    b; // 43</code></pre><p>3、上下文规则</p><ol><li><p>大括号<br> （1）对象常量<br> 用大括号定义对象常量（object literal）：</p><pre><code>     // 假定函数bar()已经定义     var a = &#123;         foo: bar()     &#125;;</code></pre><p> { .. } 被赋值给 a，因而它是一个对象常量。</p><pre><code>     （2）标签             &#123;                 foo: bar()             &#125;</code></pre><p> { .. } 在这里只是一个普通的代码块, 和 for/while 循环以及 if 条件语句中代码块的作用基本相同。<br> JavaScript 通过标签跳转能够实现 goto 的部分功能。continue 和 break 语句都可以带一个标签，因此能够像 goto 那样进行跳转。</p><pre><code>     // 标签为foo的循环     foo: for (var i=0; i&lt;4; i++) &#123;         for (var j=0; j&lt;4; j++) &#123;             // 如果j和i相等，继续外层循环             if (j == i) &#123;                 // 跳转到foo的下一个循环                 continue foo;             &#125;             // 跳过奇数结果             if ((j * i) % 2 == 1) &#123;             // 继续内层循环（没有标签的）             continue;             &#125;             console.log( i, j );         &#125;     &#125;     // 1 0     // 2 0     // 2 1     // 3 0     // 3 2</code></pre><p> contine foo 并不是指“跳转到标签 foo 所在位置继续执行”，而是“执行 foo 循环的下一轮循环”。</p><pre><code>     // 标签为foo的循环     foo: for (var i=0; i&lt;4; i++) &#123;         for (var j=0; j&lt;4; j++) &#123;             if ((i * j) &gt;= 3) &#123;                 console.log( &quot;stopping!&quot;, i, j );                 break foo;             &#125;             console.log( i, j );         &#125;     &#125;     // 0 0     // 0 1     // 0 2     // 0 3     // 1 0     // 1 1     // 1 2     // 停止！ 1 3</code></pre><p> break foo 不是指“跳转到标签 foo 所在位置继续执行”，而是“跳出标签 foo 所在的循环 / 代码块，继续执行后面的代码”。</p></li><li><p>代码块</p><pre><code> [] + &#123;&#125;; // &quot;[object Object]&quot; &#123;&#125; + []; // 0</code></pre></li></ol><p>第一行代码中，{} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。第 4 章讲过 [] 会被强制类型转换为 “”，而 {} 会被强制类型转换为 “[object Object]”。<br>在第二行代码中，{} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换（参见第 4 章）为 0。</p><ol start="3"><li><p> 对象结构</p></li><li><p>else if 和可选代码块</p><pre><code>  if () &#123;...&#125;  else &#123;      if () &#123;...&#125;  &#125; 👇 if () ... else if () &#123;...&#125; 👇 if () ... else if () ...</code></pre><p> if (b) { .. } else { .. } 实际上是跟在 else 后面的一个单独的语句，所以带不带 { } 都<br> 可以。换句话说，else if 不符合前面介绍的编码规范，else 中是一个单独的 if 语句。这只是我们自己发明的用法</p></li></ol><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>1、短路<br>2、更强的绑定<br>3、关联<br>4、释疑</p><h4 id="自动分号"><a href="#自动分号" class="headerlink" title="自动分号"></a>自动分号</h4><p>有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic Semicolon<br>Insertion，ASI）。<br>ASI 只在换行符处起作用，而不会在代码行的中间插入分号。</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><h4 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h4><p>如果 finally 中抛出异常（无论是有意还是无意），函数就会在此处终止。如果此前 try 中<br>已经有 return 设置了返回值，则该值会被丢弃<br>finally 中的 return 会覆盖 try 和 catch 中 return 的返回值</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>有时可能会需要通过强制类型转换来进行相等比较（即 ==，参见第 4 章），这时就需要做一些特殊处理：</p><pre><code>    var a = &quot;42&quot;;    switch (true) &#123;        case a == 10:            console.log( &quot;10 or &#39;10&#39;&quot; );        break;        case a == 42;            console.log( &quot;42 or &#39;42&#39;&quot; );        break;        default:        // 永远执行不到这里    &#125;    // 42 or &#39;42&#39;</code></pre><p>除简单值以外，case 中还可以出现各种表达式，它会将表达式的结果值和 true 进行比较。因为 a == 42 的结果为 true，所以条件成立。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>语句和表达式在英语中都能找到类比——语句就像英语中的句子，而表达式就像短语。表达式可以是简单独立的，否则可能会产生副作用。<br>JavaScript 语法规则之上是语义规则（也称作上下文）。例如，{ } 在不同情况下的意思不尽相同，可以是语句块、对象常量、解构赋值（ES6）或者命名函数参数（ES6）。<br>JavaScript 详细定义了运算符的优先级（运算符执行的先后顺序）和关联（多个运算符的组合方式）。只要熟练掌握了这些规则，就能对如何合理地运用它们作出自己的判断。<br>ASI（自动分号插入）是 JavaScript 引擎的代码解析纠错机制，它会在需要的地方自动插入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的（可以省略），或者由于分号缺失导致的错误是否都可以交给 JavaScript 引擎来处理。<br>JavaScript 中有很多错误类型，分为两大类：早期错误（编译时错误，无法被捕获）和运行时错误（可以通过 try..catch 来捕获）。所有语法错误都是早期错误，程序有语法错误则无法运行。<br>函数参数和命名参数之间的关系非常微妙。尤其是 arguments 数组，它的抽象泄漏给我们挖了不少坑。因此，尽量不要使用 arguments，如果非用不可，也切勿同时使用 arguments 和其对应的命名参数。<br>finally 中代码的处理顺序需要特别注意。它们有时能派上很大用场，但也容易引起困惑，特别是在和带标签的代码块混用时。总之，使用 finally 旨在让代码更加简洁易读，切忌弄巧成拙。<br>switch 相对于 if..else if.. 来说更为简洁。需要注意的一点是，如果对其理解得不够透彻，稍不注意就很容易出错。</p><h3 id="第二部分：异步和性能"><a href="#第二部分：异步和性能" class="headerlink" title="第二部分：异步和性能"></a>第二部分：异步和性能</h3><h3 id="第-1-章：异步：现在与将来"><a href="#第-1-章：异步：现在与将来" class="headerlink" title="第 1 章：异步：现在与将来"></a>第 1 章：异步：现在与将来</h3><h4 id="分块的程序"><a href="#分块的程序" class="headerlink" title="分块的程序"></a>分块的程序</h4><p>任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点<br>击、Ajax 响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序<br>中引入了异步机制。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>JavaScript 引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是 Web 浏览器。经过最近几年（不仅于此）的发展，JavaScript 已经超出了浏览器的范围，进入了其他环境，比如通过像 Node.js 这样的工具进入服务器领域。<br>所有这些环境都有一个共同“点”（thread，也指线程。不论真假与否，这都不算一个很精妙的异步笑话），即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为事件循环。<br>JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”（JavaScript 代码执行）调度总是由包含它的环境进行。### 第 2 章：回调<br>ES6 从本质上改变了在哪里管理事件循环。本来它几乎已经是一种正式的技术模型了，但现在 ES6 精确指定了事件循环的工作细节，这意味着在技术上将其纳入了 JavaScript 引擎的势力范围，而不是只由宿主环境管理。这个改变的一个主要原因是 ES6 中 Promise 的引入，因为这项技术要求对事件循环队列的调度运行能够直接进行精细控制</p><h4 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h4><p>术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。<br>并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。</p><p>与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。<br>并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。</p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>两个或多个“进程”同时执行就出现了并发，不管组成它们的单个运算是否并行执行（在独立的处理器或处理器核心上同时运行）。可以把并发看作“进程”级（或者任务级）的并行，与运算级的并行（不同处理器上的线程）相对<br>单线程事件循环是并发的一种形式<br>1、非交互<br>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤 / 事件时，如果这些任务彼此不相关，就不一定需要交互。<br>2、交互<br>并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。需要对它们的交互进行协调以避免竞态的出现。<br>另一种可能遇到的并发交互条件有时称为竞态（race），但是更精确的叫法是门闩（latch）。它的特性可以描述为“只有第一名取胜”。在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要“竞争”到终点，且只有唯一的胜利者。<br>3、协作<br>还有一种并发合作方式，称为并发协作（cooperative concurrency）。这里的重点不再是通过共享作用域中的值进行交互（尽管显然这也是允许的！）。这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>在 ES6 中，有一个新的概念建立在事件循环队列之上，叫作任务队列（job queue）。这个概念给大家带来的最大影响可能是 Promise 的异步特性</p><h4 id="语句顺序"><a href="#语句顺序" class="headerlink" title="语句顺序"></a>语句顺序</h4><p>代码中语句的顺序和 JavaScript 引擎执行语句的顺序并不一定要一致。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>实际上，JavaScript 程序总是至少分为两个块：第一块现在运行；下一块将来运行，以响应牟哥事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，<br>所以对状态的修改都是在之前累计的修改之上进行的。<br>一旦有时间需要运行，事件循环就会运行，知道队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。<br>任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。<br>并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看。就像是同时在运行（尽管在任意时刻只处理一个事件）。<br>通常需要对这些并发执行“进程”（有别于操作系统中的进程概念）进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割为更小的块，以便其他“进程”插入进来。</p><h3 id="第-2-章：回调"><a href="#第-2-章：回调" class="headerlink" title="第 2 章：回调"></a>第 2 章：回调</h3><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟，对于异步编程领域的发展，回调已经不够用了。<br>第一，大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码时坏代码，会导致坏 bug。<br>我们需要一种更同步、更顺序、更阻塞的方式来表达异步，就像我们的大脑一样。<br>第二，也是更重要的一点，回调会受到控制反转的影响，因为回调暗中把控制权交给第三方（通常是不受你控制的第三方工具！）来调用你代码中的 continuation。这种控制转移导致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。<br>可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码，并且缺少足够的保护，其中的损害要知道你受到 bug 的影响才会被发现。<br>我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可以复用，且没有重复代码的开销。<br>我们需要比回调更好的机制。</p><h3 id="第-3-章：Promise"><a href="#第-3-章：Promise" class="headerlink" title="第 3 章：Promise"></a>第 3 章：Promise</h3><p>Promise 是一种封装和组合未来值的易于复用的机制。</p><h4 id="Promise-模式"><a href="#Promise-模式" class="headerlink" title="Promise 模式"></a>Promise 模式</h4><p>1、Promise.all([ .. ])<br>从 Promise.all([ .. ]) 返回的主 promise 在且仅在所有的成员 promise 都完成后才会完<br>成。如果这些 promise 中有任何一个被拒绝的话，主 Promise.all([ .. ])promise 就会立<br>即被拒绝，并丢弃来自其他所有 promise 的全部结果。<br>2、Promise.race([ .. ])<br>一旦有任何一个 Promise 决议为完成，Promise.race([ .. ])<br>就会完成；一旦有任何一个 Promise 决议为拒绝，它就会拒绝。<br>3、all([ .. ]) 和 race([ .. ]) 的变体<br>有些 Promise 抽象库提供了这些支持，但也可以使用 Promise、race([ .. ]) 和 all([ .. ])<br>这些机制，你自己来实现它们。</p><ul><li>none([ .. ])<br>这个模式类似于 all([ .. ])，不过完成和拒绝的情况互换了。所有的 Promise 都要被拒绝，即拒绝转化为完成值，反之亦然。</li><li>any([ .. ])<br>这个模式与 all([ .. ]) 类似，但是会忽略拒绝，所以只需要完成一个而不是全部。</li><li>first([ .. ])<br>这个模式类似于与 any([ .. ]) 的竞争，即只要第一个 Promise 完成，它就会忽略后续的任何拒绝和完成。</li><li>last([ .. ])<br>这个模式类似于 first([ .. ])，但却是只有最后一个完成胜出。</li></ul><p>4、并发迭代</p><pre><code>    var p1 = Promise.resolve( 21 );    var p2 = Promise.resolve( 42 );    var p3 = Promise.reject( &quot;Oops&quot; );    // 把列表中的值加倍，即使是在 Promise 中    Promise.map( [p1,p2,p3], function(pr,done)&#123;        // 保证这一条本身是一个 Promise        Promise.resolve( pr )        .then(        // 提取值作为 v            function(v)&#123;            // map 完成的 v 到新值            done( v \* 2 );            &#125;,            // 或者 map 到 promise 拒绝消息            done        );        &#125; )        .then( function(vals)&#123;            console.log( vals ); // [42,84,&quot;Oops&quot;]    &#125; );</code></pre><h4 id="Promise-API-概述"><a href="#Promise-API-概述" class="headerlink" title="Promise API 概述"></a>Promise API 概述</h4><p>1、new Promise(..)构造器<br>有启示性的构造器 Promise(..) 必须和 new 一起使用，并且必须提供一个函数回调。这个回调是同步的或立即调用的。这个函数接受两个函数回调，用以支持 promise 的决议。通常我们把这两个函数称为 resolve(..) 和 reject(..)<br>2、Promise.resolve(..) 和 Promise.reject(..)<br>创建一个已被拒绝的 Promise 的快捷方式是使用 Promise.reject(..)，所以以下两个<br>promise 是等价的：</p><pre><code>    var p1 = new Promise( function(resolve,reject)&#123;        reject( &quot;Oops&quot; );    &#125; );    var p2 = Promise.reject( &quot;Oops&quot; );</code></pre><p>Promise.resolve(..) 常用于创建一个已完成的 Promise，使用方式与 Promise.reject(..)类似。但是，Promise.resolve(..) 也会展开 thenable 值（前面已多次介绍）。在这种情况<br>下，返回的 Promise 采用传入的这个 thenable 的最终决议值，可能是完成，也可能是拒绝<br>如果传入的是真正的 Promise，Promise.resolve(..) 什么都不会做，只会直接把这个值返回。所以，对你不了解属性的值调用 Promise.resolve(..)，如果它恰好是一个真正的 Promise，是不会有额外的开销的。<br>3、then(..) 和 catch(..)<br>then(..) 接受一个或两个参数：第一个用于完成回调，第二个用于拒绝回调。如果两者中的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回调只是把消息传递下去，而默认拒绝回调则只是重新抛出（传播）其接收到的出错原因。<br>catch(..) 只接受一个拒绝回调作为参数，并自动替换默认完成回调。它等价于 then(null,..)<br>then(..) 和 catch(..) 也会创建并返回一个新的 promise，这个 promise 可以用于实现 Promise 链式流程控制。如果完成或拒绝回调中抛出异常，返回的 promise 是被拒绝的。如果任意一个回调返回非 Promise、非 thenable 的立即值，这个值会被用作返回 promise 的完成值。如果完成处理函数返回一个 promise 或 thenable，那么这个值会被展开，并作为返回 promise 的决议值。<br>4、Promise.all([ .. ]) 和 Promise.race([ .. ])<br>ES6 Promise API 静态辅助函数 Promise.all([ .. ]) 和 Promise.race([ .. ]) 都会创建一个 Promise 作为它们的返回值。这个 promise 的决议完全由传入的 promise 数组控制。<br>若向 Promise.all([ .. ]) 传入空数组，它会立即完成，但 Promise.race([ .. ]) 会挂住，且永远不会决议。</p><h4 id="Promise-局限性"><a href="#Promise-局限性" class="headerlink" title="Promise 局限性"></a>Promise 局限性</h4><p>1、顺序错误处理<br>Promise 链中的错误很容易被无意中默默忽略掉。<br>如果构建了一个没有错误处理函数的 Promise 链，链中任何地方的任何错误都会在链中一直传播下去，直到被查看（通过在某个步骤注册拒绝处理函数）。<br>基本上，这等同于 try..catch 存在的局限：try..catch 可能捕获一个异常并简单地吞掉<br>它。所以这并不是 Promise 独有的局限性<br>2、单一值</p><ol><li>分裂值</li><li>展开/传递参数</li></ol><p>3、单决议<br>Promise 最本质的一个特征是：Promise 只能被决议一次（完成或拒绝）。<br>但是，还有很多异步的情况适合另一种模式——一种类似于事件和 / 或数据流的模式。在表面上，目前还不清楚 Promise 能不能很好用于这样的用例，如果不是完全不可用的话。如果不在 Promise 之上构建显著的抽象，Promise 肯定完全无法支持多值决议处理。<br>4、惯性<br>5、无法取消的 Promise<br>一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。<br>6、性能<br>把基本的基于回调的异步任务链与 Promise 链中需要移动的部分数量进行比较。很显然，Promise 进行的动作要多一些，这自然意味着它也会稍慢一些。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>Promise 非常好，请使用。它们解决了我们因只用回调的代码而备受困扰的控制反转问题。它们并没有摈弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任的中介机制。<br>Promise 链也开始提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步 JavaScript 代码。我们将在第 4 章看到针对这个问题的一种更好的解决方案！</p><h3 id="第-4-章：生成器"><a href="#第-4-章：生成器" class="headerlink" title="第 4 章：生成器"></a>第 4 章：生成器</h3><h4 id="打破完整运行"><a href="#打破完整运行" class="headerlink" title="打破完整运行"></a>打破完整运行</h4><pre><code>    var x = 1;    function* foo() &#123;        x++;        yield; // 暂停！        console.log( &quot;x:&quot;, x );    &#125;    function bar() &#123;        x++;    &#125;    // 构造一个迭代器it来控制这个生成器    var it = foo();    // 这里启动foo()！    it.next();    x; // 2    bar();    x; // 3    it.next(); // x: 3</code></pre><p>因此，生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。<br>运行过程<br>(1) it = foo() 运算并没有执行生成器 *foo()，而只是构造了一个迭代器（iterator），这个迭代器会控制它的执行。后面会介绍迭代器。<br>(2) 第一个 it.next() 启动了生成器 *foo()，并运行了 <em>foo() 第一行的 x++。<br>(3) *foo() 在 yield 语句处暂停，在这一点上第一个 it.next() 调用结束。此时 *foo() 仍在运行并且是活跃的，但处于暂停状态。<br>(4) 我们查看 x 的值，此时为 2。<br>(5) 我们调用 bar()，它通过 x++ 再次递增 x。<br>(6) 我们再次查看 x 的值，此时为 3。<br>(7) 最后的 it.next() 调用从暂停处恢复了生成器 \</em>foo() 的执行，并运行 console.log(..)语句，这条语句使用当前 x 的值 3。</p><p>foo() 启动了，但是没有完整运行，它在 yield 处暂停了。后面恢复了 foo() 并让它运行到结束，但这不是必需的。</p><p>生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。</p><p>1、输入和输出<br>next(..) 调用的结果是一个对象，它有一个 value 属性，持有从 *foo(..) 返回的值（如果有的话）。换句话说，yield 会导致生成器在执行过程中发送出一个值，这有点类似于中间的 return。</p><ol><li><p>迭代消息传递<br> 除了能够接受参数并提供返回值之外，生成器甚至提供了更强大更引人注目的内建消息输入输出能力，通过 yield 和 next(..) 实现。</p><pre><code>  function *foo(x) &#123;     var y = x * (yield);     return y;  &#125;  var it = foo( 6 );  // 启动foo(..)  it.next();  var res = it.next( 7 );  res.value; // 42</code></pre></li><li><p>两个问题的故事<br> 没有向第一个 next() 调用发送值，这是有意为之。只有暂停的 yield 才能接受这样一个通过 next(..) 传递的值，而在生成器的起始处我们调用第一个 next() 时，还没有暂停的 yield 来接受这样一个值。</p></li></ol><p>2、多个迭代器<br>每次构建一个迭代器，实际上就隐式构建了生成器的一个实例，通过这个迭代器来控制的是这个生成器实例。<br>同一个生成器的多个实例可以同时运行，它们甚至可以彼此交互：</p><pre><code>    function *foo() &#123;        var x = yield 2;        z++;        var y = yield (x * z);        console.log( x, y, z );    &#125;    var z = 1;    var it1 = foo();    var it2 = foo();    var val1 = it1.next().value;            // 2 &lt;-- yield 2    var val2 = it2.next().value;            // 2 &lt;-- yield 2    val1 = it1.next( val2 * 10 ).value;     // 40 &lt;-- x:20, z:2    val2 = it2.next( val1 * 5 ).value;      // 600 &lt;-- x:200, z:3    it1.next( val2 / 2 );                   // y:300                                            // 20 300 3    it2.next( val1 / 4 );                   // y:10                                            // 200 10 3</code></pre><p>执行流程<br>(1) *foo() 的两个实例同时启动，两个 next() 分别从 yield 2 语句得到值 2。<br>(2) val2 * 10 也就是 2 * 10，发送到第一个生成器实例 it1，因此 x 得到值 20。z 从 1 增<br>加到 2，然后 20 * 2 通过 yield 发出，将 val1 设置为 40。<br>(3) val1 * 5 也就是 40 * 5，发送到第二个生成器实例 it2，因此 x 得到值 200。z 再次从 2<br>递增到 3，然后 200 * 3 通过 yield 发出，将 val2 设置为 600。<br>(4) val2 / 2 也就是 600 / 2，发送到第一个生成器实例 it1，因此 y 得到值 300，然后打印<br>出 x y z 的值分别是 20 300 3。<br>(5) val1 / 4 也就是 40 / 4，发送到第二个生成器实例 it2，因此 y 得到值 10，然后打印出<br>x y z 的值分别为 200 10 3。</p><h4 id="生成器产生值"><a href="#生成器产生值" class="headerlink" title="生成器产生值"></a>生成器产生值</h4><p>1、生产者与迭代器<br>2、iterable<br>3、生成器迭代器</p><h4 id="异步迭代生成器"><a href="#异步迭代生成器" class="headerlink" title="异步迭代生成器"></a>异步迭代生成器</h4><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>生成器是 ES6 的一个新的函数类型，它并不像普通函数那样总是运行到结束。取而代之的是，生成器可以在运行当中（完全保持其状态）暂停，并且将来再从暂停的地方恢复运行。<br>这种交替的暂停和恢复是合作性的而不是抢占式的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字 yield 实现的。不过，只有控制生成器的迭代器具有恢复生成器的能力（通过 next(…)）。<br>yield/next(…)这一对不只是一种控制机制，实际上也是一种双向消息传递机制。yield..表达式本质上是暂停下来等待某个值，接下来 next(…)调用会向被暂停的 yield 表达式传回一个值（或者是隐式的 undefined）。<br>在异步控制流程方面，生成器的关键优点是：生成器内部的代码是以自然的同步/顺序方式表达任务的一系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字 yield 的后面，把异步移动到控制生成器的迭代器的代码部分。<br>换句话说，生成器为异步代码保持了顺序、同步、阻塞的代码模式，这使得大脑可以更自然地追踪代码，解决了基于回调的异步的两个关键缺陷之一。</p><h3 id="第-5-章：程序性能"><a href="#第-5-章：程序性能" class="headerlink" title="第 5 章：程序性能"></a>第 5 章：程序性能</h3><h4 id="Web-Workeer"><a href="#Web-Workeer" class="headerlink" title="Web Workeer"></a>Web Workeer</h4><p>从 JavaScript 主程序（或另一个 Worker）中，可以这样实例化一个 Worker：</p><pre><code>    var w1=new Worker(&quot;http://some.url.1/mycoolworker.js&quot;);</code></pre><p>这个 URL 应该指向一个 JavaScript 文件的文职（而不是一个 HTML 页面），这个文件将被加载到一个 Worker 中。然后浏览器启动一个独立的线程，让这个文件在这个线程中作为独立的程序运行。</p><p>Worker 之间以及他们和主程序之间，不会共享任务任何作用域或资源，那会把所有多线程编程的噩梦带到前端领域，而是通过一个基本的事件消息机制相互联系。<br>Worker w1 对象是一个事件侦听者和触发者，可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。<br>通常由主页面应用程序创建 Worker，但若是需要的话，Worker 也可以实例化它自己的子 Worker，成为 subworkder。有时候，把这样的细节委托给一个“主”Worker，由它来创建其他 Worker 处理部分任务，这样很有用。</p><p>1、Worker 环境<br>在 Worker 内部是无法访问主程序的任何资源的。这意味着不能访问它的任何全局变量，也不能访问页面的 DOM 或者其他资源。这是一个完全独立的线程。<br>但是可以执行网络操作（Ajax、WebSockets）以及设定定时器。还有，Worker 可以访问几个重要的全局变量和功能的本地复本，包括 navigator、location、JSON 和 applicationCache。</p><p>还可以通过 importScripts(..)向 Worker 加载额外的 JavaScript 脚本。这些脚本加载是同步的。会阻塞余下 Worker 的执行，直到文件加载和执行完成。<br>Web Worker 通常应用于：</p><ul><li>处理密集型数学计算</li><li>大数据集排序</li><li>数据处理（压缩、音频分析、图像处理等）</li><li>高流量网络通信</li></ul><p>2、数据传递</p><ol><li>结构化克隆算法</li><li>Transferable 对象</li></ol><p>3、共享 Worker<br>防止重复专用 Worker 来降低系统的资源使用，创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker 就非常有用了。<br>这称为 ShareWorker，可通过下面的方式创建</p><pre><code>    var w1=new SharedWorker(&quot;http://some.url.1/mycoolworker.js&quot;);</code></pre><p>因为共享 Worker 可以与站点的多个程序实例或者多个页面连接，所以这个 Worker 需要通过某种方式得知消息来自于哪个程序。这个唯一标识符称为端口（port），可以类比网络 socket 的端口。因此，调用程序必须使用 Worker 的 port 对象用于通信：</p><pre><code>    w1.port.addEventListenner(&#39;message&#39;,handleMessage);    //..    w1.port.postMessage(&quot;something cool&quot;);</code></pre><p>还有，端口连接必须要初始化，形式如下：</p><pre><code>    w1.port.start();</code></pre><p>4、模拟 Web Worker<br>JavaScript 的异步来自于事件循环队列，所以可使用定时器（setTimeout(…)等）强制模拟实现异步的伪 Worker。（<a href="https://gist.github.com/getify/1b26accb1a09aa53ad25%EF%BC%89">https://gist.github.com/getify/1b26accb1a09aa53ad25）</a></p><h4 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h4><p>单指令多数据（SIMD）是一种数据并行（data parallelism）方式，与 Web Worker 的任务并行（task parallelism）相对，因为这里的重点实际上不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。</p><h4 id="asm-js"><a href="#asm-js" class="headerlink" title="asm.js"></a>asm.js</h4><p>1、如何使用 asm.js 优化<br>2、asm.js 模块</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p>异步编码模式使我们能够编写更高效的代码，通常能够带来非常大的改进。但是，异步特性本质上还是绑定在一个单事件循环线程上。</p><p>Web Worker 可以在独立的线程运行一个 JavaScript 文件（即程序），使用异步事件在线程之间传递消息。非常适用于把长时间的或资源密集型的任务卸载到不同的线程中，以提高主 UI 线程的响应性。<br>SIMD 打算把 CPU 级的并行数学运算映射到 JavaScript API，以获得高性能的数据并行运算，比如在大数据集上的数字处理。<br>最后，asm.js 描述了 JavaScript 的一个很小的子集，它避免了 JavaScript 难以优化的部分（比如垃圾收集和强制类型转换），并且让 JavaScript 引擎识别并通过激进的优化运行这样的代码。可以手工编写 asm.js 但是会极端费力且容易出错，类似于手写汇编语言（这也是其名字的由来）。实际上，asm.js 也是高度优化的程序语言交叉编译的一个很好的目标</p><h3 id="第-6-章：性能测试与调优"><a href="#第-6-章：性能测试与调优" class="headerlink" title="第 6 章：性能测试与调优"></a>第 6 章：性能测试与调优</h3><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>1、重复<br>2、Benchmark.js</p><h4 id="环境为王"><a href="#环境为王" class="headerlink" title="环境为王"></a>环境为王</h4><h4 id="jsPerf-com"><a href="#jsPerf-com" class="headerlink" title="jsPerf.com"></a>jsPerf.com</h4><h4 id="写好测试"><a href="#写好测试" class="headerlink" title="写好测试"></a>写好测试</h4><h4 id="微性能"><a href="#微性能" class="headerlink" title="微性能"></a>微性能</h4><h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p>对一段代码进行有效的性能测试，特别是与同样代码的另外一个选择对比来看看哪种方案更快，需要认真注意细节。<br>与其打造你自己的统计有效的性能测试逻辑，不如直接使用 Benchmark.js 库，它已经为你实现了这些。但是，编写测试要小心，因为我们很容易就会构造一个看似有效实际却有缺陷的测试，即使是微小的差异也可能扭曲结果，使其完全不可靠。<br>从尽可能多的环境中得到尽可能多的测试结果以消除硬件/设备的偏差，这一点很重要。jsPerf.com 是很好的网站，用于众包性能测试运行。<br>遗憾的是，很多常用的性能测试执迷于无关紧要的微观性能细节，比如 x++对比++x。编写好的测试意味着理解如何关注大局，比如关键路径上的优化以及避免落入类似不同的 JavaScript 实现细节这样的陷阱中。<br>尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变得实际。TCO 允许一个函数在结尾处调用另外一个函数来执行，不需要任何额外资源。这意味着，对递归算法来说，引擎不再需要限制栈深度。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复制图片+文字</title>
      <link href="/2021/05/08/%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87-%E6%96%87%E5%AD%97/"/>
      <url>/2021/05/08/%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87-%E6%96%87%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h5 id="项目需求，复制文案需要图片-文字，可贴在微信聊天框内"><a href="#项目需求，复制文案需要图片-文字，可贴在微信聊天框内" class="headerlink" title="项目需求，复制文案需要图片+文字，可贴在微信聊天框内"></a>项目需求，复制文案需要图片+文字，可贴在微信聊天框内</h5><pre><code>    export const copyNode = &#123;                _copy: function(el, type) &#123;                    if (el) &#123;                        const node = document.querySelector(el)                        let range = document.createRange()                        const selection = window.getSelection()                        switch (type) &#123;                            case &#39;node&#39;:                                range.selectNode(node)                                break                            case &#39;nodeContents&#39;:                                range.selectNodeContents(node)                                break                            default:                                break                        &#125;                        selection.empty()                        selection.addRange(range)                        try &#123;                            document.execCommand(&#39;copy&#39;)                            // eslint-disable-next-line                            Message(&#123;                                message: &#39;复制成功&#39;,                                duration: 800,                                type: &#39;success&#39;,                            &#125;)                        &#125; catch (error) &#123;                            // eslint-disable-next-line                            Message(&#123;                                message: &#39;复制失败&#39;,                                duration: 800,                                type: &#39;warning&#39;,                            &#125;)                        &#125;                        selection.empty()                        range.detach()                        range = null                    &#125; else &#123;                        // eslint-disable-next-line                        Message(&#123;                            message: &#39;复制失败&#39;,                            duration: 800,                            type: &#39;warning&#39;,                        &#125;)                    &#125;                &#125;,                copyNode: function(el) &#123; // 直接复制这个Node节点，el：document.querySelector(el)                    this._copy(el, &#39;node&#39;)                &#125;,                copyNodeContents: function(el) &#123; // 复制这个Node节点内的子孙节点，el：document.querySelector(el)                    this._copy(el, &#39;nodeContents&#39;)                &#125;,            &#125;</code></pre><h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><pre><code>https 的图片无法拷贝</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue打包静态资源部署到另外服务器</title>
      <link href="/2021/04/05/vue%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2%E5%88%B0%E5%8F%A6%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2021/04/05/vue%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%83%A8%E7%BD%B2%E5%88%B0%E5%8F%A6%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>因某种原因，项目部署在国外服务器上，但是网速太慢，静态资源另外部署到国内服务器<br>vue.config.js</p><pre><code>    const isProduction = process.env.NODE_ENV === &#39;production&#39;    module.exports = &#123;        publicPath: isProduction ? process.env.VUE_APP_NB_STATIC_URL : &#39;/&#39;,    &#125;</code></pre><p>另外需要将路由改为哈希模式,注掉即可</p><pre><code>    const router = new VueRouter(&#123;        // mode: &#39;history&#39;,        base: process.env.BASE_URL,        routes,    &#125;)</code></pre><p>因为跨域，需设置静态资源服务器nginx请求头</p><pre><code>    location / &#123;          add_header Access-Control-Allow-Origin *;        add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;        add_header Access-Control-Allow-Headers &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#39;;        if ($request_method = &#39;OPTIONS&#39;) &#123;            return 204;        &#125;    &#125; </code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>indexDB存储数据</title>
      <link href="/2021/03/27/indexDB%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/03/27/indexDB%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>由于业务需要缓存大量聊天记录，存储在服务器端压力略大，所以转为存储在客户端<br>原生 indexDB 无批量插入数据接口，运用了 <a href="https://dexie.org/">Dexie.js</a> 插件，dexie 提供 api 大量插入数据，优化了回调，只回调最后一次</p><pre><code>npm install dexie</code></pre><p>创建仓库</p><pre><code>import Dexie from &#39;dexie&#39;;const LAST_VERSION_NO = 0.4;const NAME_DATABASE = &#39;WeiDB&#39;;const currentTables = &#123;friends: &#39;++friendInnerId&#39;,groups: &#39;++groupInnerId&#39;,historyMsgs: &#39;++id,messageKey,newMsgId,sortTime&#39;,newMsgList: &#39;++messageKey,newMsgId,sortTime&#39;&#125;;const db = new Dexie(NAME_DATABASE);db.version(LAST_VERSION_NO).stores(currentTables).upgrade(trans =&gt; &#123;console.log(`db：upgrade-version($&#123;LAST_VERSION_NO&#125;)`);&#125;);console.log(`db：version($&#123;db.verno&#125;)`);export default db;</code></pre><p>因为我的业务需要存储好友列表，群组列表，历史消息，同时要最近消息列表的功能，并且是多个账号同时在线，且可能存在相同好友和群组<br>所以我初建了四个表，前两个表如名，分别存储好友和群组，historyMsgs 存储历史消息，newMsgList 存储最近消息列表</p><p>historyMsgs 我创建了四个索引，id 为自动生成的唯一主键，messageKey 为聊天双方对象 key，newMsgId 为消息唯一 ID，多个账号收到同一个群的同一条消息，newMsgId 也相同，sortTime 则单纯为了排序</p><p>newMsgList 我创建了三个索引，messageKey 为唯一主键，只存储聊天对儿的最后一条数据，用于最近消息展示。索引的数据内容同上</p><pre><code>import dbDexie from &#39;./dexie&#39;;/*** 添加历史消息记录并更新最近消息列表状态*/export function addMsg2DB(NewMsg) &#123;  dbDexie.transaction(    &#39;rw&#39;,    dbDexie.historyMsgs,    dbDexie.newMsgList,    async () =&gt; &#123;      const messageKey = `$&#123;NewMsg.wxId&#125;|$&#123;NewMsg.GroupUsername ||        NewMsg.Username&#125;`;      // NewMsg.CreateTime只能精确到秒级别，      const sortTime = new Date().getTime();      const historyMsgData = &#123;        ...NewMsg,        ...&#123;          sortTime,          messageKey        &#125;      &#125;;      dbDexie.historyMsgs        .put(historyMsgData)        .then(DBId =&gt; &#123;          console.log(&#39;DB添加新消息：&#39;, messageKey, historyMsgData);          dbDexie.newMsgList.get(messageKey).then(result =&gt; &#123;            const unReadNum =              NewMsg.isSelf || NewMsg.currChatClient                ? 0                : result                  ? result.unReadNum + 1                  : 1;            const newMsgListData = &#123;              ...NewMsg,              ...&#123;                messageKey,                lastChatMsgId: DBId,                unReadNum,                sortTime              &#125;            &#125;;            dbDexie.newMsgList.put(newMsgListData).then(() =&gt; &#123;&#125;);          &#125;);        &#125;)        .catch(err =&gt; &#123;          console.log(&#39;添加失败&#39;, err);        &#125;);    &#125;  );&#125;/*** 被撤回的消息状态修改*/export function revokeDBMsg(newMsgId) &#123;  dbDexie.transaction(    &#39;rw&#39;,    dbDexie.historyMsgs,    dbDexie.newMsgList,    async () =&gt; &#123;      dbDexie.historyMsgs        .where(&#123; newMsgId &#125;)        .modify(&#123; type: &#39;revoke&#39;, revoked: 1 &#125;)        .then(result =&gt; &#123;          console.log(&#39;db历史消息记录撤回成功：&#39;, result);        &#125;)        .catch(err =&gt; &#123;          console.log(&#39;db历史消息记录撤回失败&#39;, err);        &#125;);      dbDexie.newMsgList        .where(&#123; newMsgId &#125;)        .modify(&#123; type: &#39;revoke&#39;, revoked: 1 &#125;)        .then(result =&gt; &#123;          console.log(&#39;db消息列表撤回成功：&#39;, result);        &#125;)        .catch(err =&gt; &#123;          console.log(&#39;db消息列表撤回失败&#39;, err);        &#125;);    &#125;  );&#125;/*** 删除历史消息记录*/export function delDBMsgs(params) &#123;  dbDexie.transaction(    &#39;rw&#39;,    dbDexie.historyMsgs,    dbDexie.newMsgList,    async () =&gt; &#123;      const messageKey = `$&#123;params.wxid&#125;|$&#123;params.msgWith&#125;`;      dbDexie.newMsgList.delete(messageKey);      dbDexie.historyMsgs        .where(&#39;messageKey&#39;)        .anyOf(messageKey)        .delete()        .then(deleteCount =&gt; &#123;          console.log(`删除$&#123;messageKey&#125;&quot; + $&#123;deleteCount&#125; + &quot; 条记录`);        &#125;)        .catch(err =&gt; &#123;          console.log(`删除失败，$&#123;err&#125;`);        &#125;);    &#125;  );&#125;/*** 获取历史消息记录*/export function getMsgsFromDB(params) &#123;  return new Promise(resolve =&gt; &#123;    dbDexie.transaction(&#39;rw&#39;, dbDexie.historyMsgs, async () =&gt; &#123;      const isGroup = /@chatroom$/.test(params.msgWith);      const messageKey = `$&#123;params.wxid&#125;|$&#123;params.msgWith&#125;`;      dbDexie.historyMsgs        .where(&#123; messageKey &#125;)        .filter(msg =&gt; &#123;          if (isGroup) &#123;            return params.id ? msg.DBId &lt; params.id : true;          &#125;          return (            !msg.GroupUsername &amp;&amp; (params.id ? msg.DBId &lt; params.id : true)          );        &#125;)        .limit(params.size)        .reverse()        .sortBy(&#39;sortTime&#39;)        .then(msgs =&gt; &#123;          const result = msgs.map(i =&gt; (&#123;            id: i.DBId,            buffer: i.Content.Buffer,            createTime: i.CreateTime,            // data: &#39;&#39;,            icon: i.Sender &amp;&amp; i.Sender.Icon.Small,            // isAdmin: 0,            // msgId: &#39;1100760167&#39;,            msgSender: (i.Sender &amp;&amp; i.Sender.Username) || i.Username,            msgType: i.Content.MsgType,            msgWith: i.GroupUsername || i.Username,            newMsgId: i.newMsgId,            nickname: i.Sender &amp;&amp; i.Sender.Nickname,            // other: 0,            revoked: i.revoked,            self:              i.isSelf ||              Boolean(i.Sender &amp;&amp; i.Sender.Username === params.wxid),            text: i.Content.Text,            // userId: 7,            wxid: i.wxId,            data: i.url,            xml: i.Content.Xml          &#125;));          resolve(result);        &#125;);    &#125;);  &#125;);&#125;/*** 获取最近消息列表*/export function getNewMsgListFromDB() &#123;  return new Promise(resolve =&gt; &#123;    dbDexie.transaction(&#39;rw&#39;, dbDexie.newMsgList, async () =&gt; &#123;      dbDexie.newMsgList        .orderBy(&#39;sortTime&#39;)        .reverse()        .toArray()        .then(list =&gt; &#123;          const result = list.map(i =&gt; (&#123;            // id: i.lastChatMsgId,            buffer: i.Content.Buffer,            createTime: i.CreateTime,            // data: &quot;&quot;,            icon: i.Sender &amp;&amp; i.Sender.Icon.Small,            // isAdmin: 0,            // msgId: &quot;1100760391&quot;,            msgSender: (i.Sender &amp;&amp; i.Sender.Username) || i.Username,            msgType: i.Content.MsgType,            msgWith: i.GroupUsername || i.Username,            newMsgId: i.newMsgId,            nickname: i.Sender &amp;&amp; i.Sender.Nickname,            // other: 0,            revoked: i.revoked,            self: i.isSelf,            text: i.Content.Text,            // userId: 7,            wxid: i.wxId,            xml: i.Content.Xml,            messageKey: i.messageKey,            sortTime: i.sortTime,            unReadNum: i.unReadNum          &#125;));          resolve(result);        &#125;);    &#125;);  &#125;);&#125;/*** 清零未读消息数*/export function updateDBUnreadNum(messageKey) &#123;  dbDexie.transaction(&#39;rw&#39;, dbDexie.newMsgList, async () =&gt; &#123;    dbDexie.newMsgList      .update(messageKey, &#123; unReadNum: 0 &#125;)      .then(function(updated) &#123;        if (updated) console.log(`$&#123;messageKey&#125;，未读消息数清零`);        else console.log(`$&#123;messageKey&#125;清零失败`);      &#125;);  &#125;);&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> indexDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter打包apk签名</title>
      <link href="/2021/03/27/flutter%E6%89%93%E5%8C%85apk%E7%AD%BE%E5%90%8D/"/>
      <url>/2021/03/27/flutter%E6%89%93%E5%8C%85apk%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>命令行输入下方命令，并一次填写对应信息，口令外的可不填</p><pre><code>    keytool -genkey -v -keystore ./key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key    输入密钥库口令:    再次输入新口令:    您的名字与姓氏是什么?        [unknown]:    您的组织单位名称是什么?        [Unknown]:    您的组织名称是什么?        [Unknown]:    您所在的城市或区域名称是什么?        [Unknown]:    您所在的省/市/自治区名称是什么?        [Unknown]:    该单位的双字母国家/地区代码是什么?        [Unknown]:    CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown是否正确?        [否]:y    正在为以下对象生成 2,048 位RSA密钥对和自签名证书 (SHA256withRSA) (有效期为 10,000 天):     CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown    输入 &lt;key&gt; 的密钥口令    (如果和密钥库口令相同, 按回车):</code></pre><p>即可在当前目录生成 key.jks 签名文件</p><p>然后在 android 文件夹下创建 key.properties 文件</p><pre><code>    storePassword=口令密码    keyPassword=口令密码    keyAlias=key.jks的文件名即key    storeFile=签名文件路径(如果用相对路径，则为android下的app下build.gradle的相对路径)</code></pre><p>在 android 下 app 下 build.gradle 文件配置签名信息</p><pre><code>    android &#123;        ...        signingConfigs &#123;            release &#123;                keyAlias keystoreProperties[&#39;keyAlias&#39;]                keyPassword keystoreProperties[&#39;keyPassword&#39;]                storeFile keystoreProperties[&#39;storeFile&#39;] ? file(keystoreProperties[&#39;storeFile&#39;]) : null                storePassword keystoreProperties[&#39;storePassword&#39;]            &#125;        &#125;        buildTypes &#123;            release &#123;                signingConfig signingConfigs.release            &#125;        &#125;        ...     &#125;</code></pre><p>打包出来的 apk 检测签名有效期</p><pre><code>     jarsigner -verify -verbose -certs app-release.apk</code></pre><p>第三方接口需要调试版安全码 SHA1 和发布版安全码 SHA1 时，</p><pre><code>    keytool -v -list -keystore key.jks    输入密钥库口令:    密钥库类型: PKCS12    密钥库提供方: SUN    您的密钥库包含 1 个条目    别名: key    创建日期: 2021-3-27    条目类型: PrivateKeyEntry    证书链长度: 1    证书[1]:    所有者: CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown    发布者: CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown    序列号: 6408c630    有效期为 Sat Mar 27 13:07:03 CST 2021 至 Wed Aug 12 13:07:03 CST 2048    证书指纹:            MD5:  **********************************************************            SHA1: **********************************************************            SHA256: **********************************************************        签名算法名称: SHA256withRSA    主体公共密钥算法: 2048 位 RSA 密钥    版本: 3    扩展:    #1: ObjectId: 2.5.29.14 Criticality=false    SubjectKeyIdentifier [    KeyIdentifier [    0000: 16 F5 C9 64 34 5E 2C E6   BD 0B 5D BB 1F 19 65 F8  ...d4^,...]...e.    0010: A3 6D 8D 89                                        .m..    ]    ]    *******************************************    *******************************************</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.eslintrc</title>
      <link href="/2021/03/10/eslintrc/"/>
      <url>/2021/03/10/eslintrc/</url>
      
        <content type="html"><![CDATA[<p>{<br>  “root”: true,<br>  “env”: {<br>    “node”: true<br>  },<br>  “extends”: [“plugin:vue/essential”, “eslint:recommended”],<br>  “parserOptions”: {<br>    “parser”: “babel-eslint”<br>  },<br>  “rules”: {<br>    “no-alert”: 0, //禁止使用alert confirm prompt<br>    “no-array-constructor”: 2, //禁止使用数组构造器<br>    “no-bitwise”: 0, //禁止使用按位运算符<br>    “no-caller”: 1, //禁止使用arguments.caller或arguments.callee<br>    “no-catch-shadow”: 2, //禁止catch子句参数与外部作用域变量同名<br>    “no-class-assign”: 2, //禁止给类赋值<br>    “no-cond-assign”: 2, //禁止在条件表达式中使用赋值语句<br>    “no-console”: 2, //禁止使用console<br>    “no-const-assign”: 2, //禁止修改const声明的变量<br>    “no-constant-condition”: 2, //禁止在条件中使用常量表达式 if(true) if(1)<br>    “no-continue”: 0, //禁止使用continue<br>    “no-control-regex”: 2, //禁止在正则表达式中使用控制字符<br>    “no-debugger”: 2, //禁止使用debugger<br>    “no-delete-var”: 2, //不能对var声明的变量使用delete操作符<br>    “no-div-regex”: 1, //不能使用看起来像除法的正则表达式/=foo/<br>    “no-dupe-keys”: 2, //在创建对象字面量时不允许键重复 {a:1,a:1}<br>    “no-dupe-args”: 2, //函数参数不能重复<br>    “no-duplicate-case”: 2, //switch中的case标签不能重复<br>    “no-else-return”: 2, //如果if语句里面有return,后面不能跟else语句<br>    “no-empty”: 2, //块语句中的内容不能为空<br>    “no-empty-character-class”: 2, //正则表达式中的[]内容不能为空<br>    “no-eq-null”: 2, //禁止对null使用==或!=运算符<br>    “no-eval”: 1, //禁止使用eval<br>    “no-ex-assign”: 2, //禁止给catch语句中的异常参数赋值<br>    “no-extend-native”: 2, //禁止扩展native对象<br>    “no-extra-bind”: 2, //禁止不必要的函数绑定<br>    “no-extra-boolean-cast”: 2, //禁止不必要的bool转换<br>    “no-extra-parens”: 2, //禁止非必要的括号<br>    “no-extra-semi”: 2, //禁止多余的冒号<br>    “no-fallthrough”: 1, //禁止switch穿透<br>    “no-floating-decimal”: 2, //禁止省略浮点数中的0 .5 3.<br>    “no-func-assign”: 2, //禁止重复的函数声明<br>    “no-implicit-coercion”: 1, //禁止隐式转换<br>    “no-implied-eval”: 2, //禁止使用隐式eval<br>    “no-inline-comments”: 0, //禁止行内备注<br>    “no-inner-declarations”: [2, “functions”], //禁止在块语句中使用声明（变量或函数）<br>    “no-invalid-regexp”: 2, //禁止无效的正则表达式<br>    “no-invalid-this”: 2, //禁止无效的this，只能用在构造器，类，对象字面量<br>    “no-irregular-whitespace”: 2, //不能有不规则的空格<br>    “no-iterator”: 2, //禁止使用<strong>iterator</strong> 属性<br>    “no-label-var”: 2, //label名不能与var声明的变量名相同<br>    “no-labels”: 2, //禁止标签声明<br>    “no-lone-blocks”: 2, //禁止不必要的嵌套块<br>    “no-lonely-if”: 2, //禁止else语句内只有if语句<br>    “no-loop-func”: 1, //禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）<br>    “no-mixed-requires”: [0, false], //声明时不能混用声明类型<br>    “no-mixed-spaces-and-tabs”: [2, false], //禁止混用tab和空格<br>    “linebreak-style”: [0, “windows”], //换行风格<br>    “no-multi-spaces”: 1, //不能用多余的空格<br>    “no-multi-str”: 2, //字符串不能用\换行<br>    “no-multiple-empty-lines”: [1, { “max”: 2 }], //空行最多不能超过2行<br>    “no-native-reassign”: 2, //不能重写native对象<br>    “no-negated-in-lhs”: 2, //in 操作符的左边不能有!<br>    “no-nested-ternary”: 0, //禁止使用嵌套的三目运算<br>    “no-new”: 1, //禁止在使用new构造一个实例后不赋值<br>    “no-new-func”: 1, //禁止使用new Function<br>    “no-new-object”: 2, //禁止使用new Object()<br>    “no-new-require”: 2, //禁止使用new require<br>    “no-new-wrappers”: 2, //禁止使用new创建包装实例，new String new Boolean new Number<br>    “no-obj-calls”: 2, //不能调用内置的全局对象，比如Math() JSON()<br>    “no-octal”: 2, //禁止使用八进制数字<br>    “no-octal-escape”: 2, //禁止使用八进制转义序列<br>    “no-param-reassign”: 2, //禁止给参数重新赋值<br>    “no-path-concat”: 0, //node中不能使用__dirname或__filename做路径拼接<br>    “no-plusplus”: 0, //禁止使用++，–<br>    “no-process-env”: 0, //禁止使用process.env<br>    “no-process-exit”: 0, //禁止使用process.exit()<br>    “no-proto”: 2, //禁止使用__proto__属性<br>    “no-redeclare”: 2, //禁止重复声明变量<br>    “no-regex-spaces”: 2, //禁止在正则表达式字面量中使用多个空格 /foo bar/<br>    “no-restricted-modules”: 0, //如果禁用了指定模块，使用就会报错<br>    “no-return-assign”: 1, //return 语句中不能有赋值表达式<br>    “no-script-url”: 0, //禁止使用javascript:void(0)<br>    “no-self-compare”: 2, //不能比较自身<br>    “no-sequences”: 0, //禁止使用逗号运算符<br>    “no-shadow”: 2, //外部作用域中的变量不能与它所包含的作用域中的变量或参数同名<br>    “no-shadow-restricted-names”: 2, //严格模式中规定的限制标识符不能作为声明时的变量名使用<br>    “no-spaced-func”: 2, //函数调用时 函数名与()之间不能有空格<br>    “no-sparse-arrays”: 2, //禁止稀疏数组， [1,,2]<br>    “no-sync”: 0, //nodejs 禁止同步方法<br>    “no-ternary”: 0, //禁止使用三目运算符<br>    “no-trailing-spaces”: 1, //一行结束后面不要有空格<br>    “no-this-before-super”: 0, //在调用super()之前不能使用this或super<br>    “no-throw-literal”: 2, //禁止抛出字面量错误 throw “error”;<br>    “no-undef”: 1, //不能有未定义的变量<br>    “no-undef-init”: 2, //变量初始化时不能直接给它赋值为undefined<br>    “no-undefined”: 2, //不能使用undefined<br>    “no-unexpected-multiline”: 2, //避免多行表达式<br>    “no-underscore-dangle”: 1, //标识符不能以_开头或结尾<br>    “no-unneeded-ternary”: 2, //禁止不必要的嵌套 var isYes = answer === 1 ? true : false;<br>    “no-unreachable”: 2, //不能有无法执行的代码<br>    “no-unused-expressions”: 2, //禁止无用的表达式<br>    “no-unused-vars”: [2, { “vars”: “all”, “args”: “after-used” }], //不能有声明后未被使用的变量或参数<br>    “no-use-before-define”: 2, //未定义前不能使用<br>    “no-useless-call”: 2, //禁止不必要的call和apply<br>    “no-void”: 2, //禁用void操作符<br>    “no-var”: 0, //禁用var，用let和const代替<br>    “no-warning-comments”: [<br>      1,<br>      { “terms”: [“todo”, “fixme”, “xxx”], “location”: “start” }<br>    ], //不能有警告备注<br>    “no-with”: 2, //禁用with<br>    “array-bracket-spacing”: [2, “never”], //是否允许非空数组里面有多余的空格<br>    “arrow-parens”: 0, //箭头函数用小括号括起来<br>    “arrow-spacing”: 0, //=&gt;的前/后括号<br>    “accessor-pairs”: 0, //在对象中使用getter/setter<br>    “block-scoped-var”: 0, //块语句中使用var<br>    “brace-style”: [1, “1tbs”], //大括号风格<br>    “callback-return”: 1, //避免多次调用回调什么的<br>    “camelcase”: 2, //强制驼峰法命名<br>    “comma-dangle”: [2, “never”], //对象字面量项尾不能有逗号<br>    “comma-spacing”: 0, //逗号前后的空格<br>    “comma-style”: [2, “last”], //逗号风格，换行时在行首还是行尾<br>    “complexity”: [0, 11], //循环复杂度<br>    “computed-property-spacing”: [0, “never”], //是否允许计算后的键名什么的<br>    “consistent-return”: 0, //return 后面是否允许省略<br>    “consistent-this”: [2, “that”], //this别名<br>    “constructor-super”: 0, //非派生类不能调用super，派生类必须调用super<br>    “curly”: [2, “all”], //必须使用 if(){} 中的{}<br>    “default-case”: 2, //switch语句最后必须有default<br>    “dot-location”: 0, //对象访问符的位置，换行的时候在行首还是行尾<br>    “dot-notation”: [0, { “allowKeywords”: true }], //避免不必要的方括号<br>    “eol-last”: 0, //文件以单一的换行符结束<br>    “eqeqeq”: 2, //必须使用全等<br>    “func-names”: 0, //函数表达式必须有名字<br>    “func-style”: [0, “declaration”], //函数风格，规定只能使用函数声明/函数表达式<br>    “generator-star-spacing”: 0, //生成器函数*的前后空格<br>    “guard-for-in”: 0, //for in循环要用if语句过滤<br>    “handle-callback-err”: 0, //nodejs 处理错误<br>    “id-length”: 0, //变量名长度<br>    “indent”: [2, 2], //缩进风格<br>    “init-declarations”: 0, //声明时必须赋初值<br>    “key-spacing”: [0, { “beforeColon”: false, “afterColon”: true }], //对象字面量中冒号的前后空格<br>    “lines-around-comment”: 0, //行前/行后备注<br>    “max-depth”: [0, 4], //嵌套块深度<br>    “max-len”: [0, 80, 4], //字符串最大长度<br>    “max-nested-callbacks”: [0, 2], //回调嵌套深度<br>    “max-params”: [0, 3], //函数最多只能有3个参数<br>    “max-statements”: [0, 10], //函数内最多有几个声明<br>    “new-cap”: 2, //函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用<br>    “new-parens”: 2, //new时必须加小括号<br>    “newline-after-var”: 2, //变量声明后是否需要空一行<br>    “object-curly-spacing”: [0, “never”], //大括号内是否允许不必要的空格<br>    “object-shorthand”: 0, //强制对象字面量缩写语法<br>    “one-var”: 1, //连续声明<br>    “operator-assignment”: [0, “always”], //赋值运算符 += -=什么的<br>    “operator-linebreak”: [2, “after”], //换行时运算符在行尾还是行首<br>    “padded-blocks”: 0, //块语句内行首行尾是否要空行<br>    “prefer-const”: 0, //首选const<br>    “prefer-spread”: 0, //首选展开运算<br>    “prefer-reflect”: 0, //首选Reflect的方法<br>    “quotes”: [1, “single”], //引号类型 `` “” ‘’<br>    “quote-props”: [0, “always”], //对象字面量中的属性名是否强制双引号<br>    “radix”: 2, //parseInt必须指定第二个参数<br>    “id-match”: 0, //命名检测<br>    “require-yield”: 0, //生成器函数必须有yield<br>    “semi”: [0, “always”], //语句强制分号结尾<br>    “semi-spacing”: [1, { “before”: false, “after”: true }], //分号前后空格<br>    “sort-vars”: 0, //变量声明时排序<br>    “space-after-keywords”: [0, “always”], //关键字后面是否要空一格<br>    “space-before-blocks”: [0, “always”], //不以新行开始的块{前面要不要有空格<br>    “space-before-function-paren”: [0, “always”], //函数定义时括号前面要不要有空格<br>    “space-in-parens”: [0, “never”], //小括号里面要不要有空格<br>    “space-infix-ops”: 0, //中缀操作符周围要不要有空格<br>    “keyword-spacing”: 2, //return throw case后面要不要加空格<br>    “space-unary-ops”: [0, { “words”: true, “nonwords”: false }], //一元运算符的前/后要不要加空格<br>    “spaced-comment”: 0, //注释风格要不要有空格什么的<br>    “strict”: 2, //使用严格模式<br>    “use-isnan”: 2, //禁止比较时使用NaN，只能用isNaN()<br>    “valid-jsdoc”: 0, //jsdoc规则<br>    “valid-typeof”: 2, //必须使用合法的typeof的值<br>    “vars-on-top”: 2, //var必须放在作用域顶部<br>    “wrap-iife”: [2, “inside”], //立即执行函数表达式的小括号风格<br>    “wrap-regex”: 0, //正则表达式字面量用小括号包起来<br>    “yoda”: [2, “never”] //禁止尤达条件<br>  }<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css笔记</title>
      <link href="/2021/02/12/css/"/>
      <url>/2021/02/12/css/</url>
      
        <content type="html"><![CDATA[<ol><li><p>用 svg 当背景图时，拉伸需要加如下代码<br> url(*.svg#svgView(preserveAspectRatio(none)))</p></li><li><p>rem 是相对于根元素的字体大小的单位<br> 根据设计稿参照<br> 如 iPhone6 375x667</p><p> 屏幕宽为 100vw<br> 1vw=375px/100=3.75px<br> 100px/3.75=26.67;<br> 26.67vw = 100px = 1rem<br> 设计稿一般为 750px 则<br> html 根元素设置 font-size</p><pre><code> html&#123;     font-size:13.33vw; &#125;</code></pre><p> 页面使用时将设计稿的像素值/100=rem 数值</p></li><li><p>常用样式</p><pre><code> /** * 溢出省略号 * @param &#123;Number&#125; 行数 */ @mixin ellipsis($rowCount: 1) &#123;     overflow: hidden;     text-overflow: ellipsis;     @if $rowCount &lt;=1 &#123;         white-space: nowrap;     &#125; @else &#123;         min-width: 0;         display: -webkit-box;         -webkit-line-clamp: $rowCount;         -webkit-box-orient: vertical;     &#125; &#125; @for $i from 1 through 6 &#123;     .text-ellipsis-#&#123;$i&#125; &#123;         @include ellipsis($i);     &#125; &#125; .m-auto &#123;     margin-left: auto !important;     margin-right: auto !important; &#125; .m-l-auto &#123;     margin-left: auto !important; &#125; .m-r-auto &#123;     margin-right: auto !important; &#125; @for $i from 0 through 100 &#123;     // 只要双数和能被5除尽的数     @if $i % 2==0 or $i % 5==0 &#123;         // 得出：margin-30或者m-30         .margin-#&#123;$i&#125;,         .m-#&#123;$i&#125; &#123;             margin: $i + px !important;         &#125;         .m-x-#&#123;$i&#125; &#123;             margin-left: $i + px !important;             margin-right: $i + px !important;         &#125;         .m-y-#&#123;$i&#125; &#123;             margin-top: $i + px !important;             margin-bottom: $i + px !important;         &#125;         // 得出：padding-30或者p-30         .padding-#&#123;$i&#125;,         .p-#&#123;$i&#125; &#123;             padding: $i + px !important;         &#125;         .p-x-#&#123;$i&#125; &#123;             padding-left: $i + px !important;             padding-right: $i + px !important;         &#125;         .p-y-#&#123;$i&#125; &#123;             padding-top: $i + px !important;             padding-bottom: $i + px !important;         &#125;         @each $short, $long in l left, t top, r right, b bottom &#123;             // 缩写版，结果如： m-l-30             // 定义外边距             .m-#&#123;$short&#125;-#&#123;$i&#125; &#123;                 margin-#&#123;$long&#125;: $i + px !important;             &#125;             // 定义内边距             .p-#&#123;$short&#125;-#&#123;$i&#125; &#123;                 padding-#&#123;$long&#125;: $i + px !important;             &#125;             // 完整版，结果如：margin-left-30             // 定义外边距             .margin-#&#123;$long&#125;-#&#123;$i&#125; &#123;                 margin-#&#123;$long&#125;: $i + px !important;             &#125;             // 定义内边距             .padding-#&#123;$long&#125;-#&#123;$i&#125; &#123;                 padding-#&#123;$long&#125;: $i + px !important;             &#125;         &#125;     &#125; &#125; .flex &#123;     display: flex; &#125; .flex-col &#123;     display: flex;     flex-direction: column; &#125; .ju-start &#123;     justify-content: flex-start; &#125; .ju-end &#123;     justify-content: flex-end; &#125; .ju-center &#123;     justify-content: center; &#125; .ju-between &#123;     justify-content: space-between; &#125; .ju-around &#123;     justify-content: space-around; &#125; .ju-evenly &#123;     justify-content: space-evenly; &#125; .al-base &#123;     align-items: baseline; &#125; .al-center &#123;     align-items: center; &#125; .flex-wrap &#123;     flex-wrap: wrap; &#125; .al-start &#123;     align-items: flex-start; &#125; .al-end &#123;     align-items: flex-end; &#125; // 弹性盒占比 如flex:2 @for $i from 1 through 12 &#123;     .flex-#&#123;$i&#125; &#123;         flex: $i;     &#125; &#125; // 字体大小 如 font-size-14 @for $i from 12 through 30 &#123;     .font-size-#&#123;$i&#125; &#123;         font-size: $i + px;     &#125; &#125; // 百分比宽高 如w-100,h-100 @for $i from 5 through 100 &#123;     @if $i % 5==0 &#123;         .w-#&#123;$i&#125; &#123;             width: $i * 1% !important;         &#125;         .h-#&#123;$i&#125; &#123;             height: $i * 1% !important;         &#125;     &#125; &#125; .disabled &#123;     cursor: not-allowed; &#125; .pointer &#123;     cursor: pointer; &#125; .warning-tips &#123;     color: #e6a23c; &#125; .link-text &#123;     color: var(--el-color-primary);     cursor: pointer; &#125; .editable-cell &#123;     position: relative; &#125; .nowrap &#123;     white-space: nowrap; &#125; .zy-drawer &#123;     .filter-container &#123;         &amp;::after &#123;             content: unset;         &#125;     &#125; &#125; .filter-container &#123;     white-space: nowrap;     display: flex;     align-items: center;     flex-wrap: wrap;     position: relative;     margin-bottom: 12px;     &amp;::after &#123;         content: &quot;&quot;;         width: calc(100% + 28px);         height: 12px;         background: #f5f5f5;         position: absolute;         bottom: -12px;         left: -14px;     &#125;     .filter-item &#123;         margin-right: 12px;         margin-bottom: 14px;         &amp;.el-input,         &amp;.el-range-editor &#123;             flex: unset;             width: 220px;             display: inline-flex;         &#125;         &amp;.el-date-editor--daterange &#123;             width: 260px;         &#125;         &amp;.el-date-editor--datetimerange &#123;             width: 360px;         &#125;         &amp;.el-button &#123;             margin-left: 0;             &amp;:first-of-type &#123;                 margin-left: auto;             &#125;         &#125;         &amp;.el-cascader &#123;             .el-input &#123;                 height: 32px;             &#125;         &#125;     &#125;     + .handle-container,     + .zn-table-content &#123;         margin-top: 14px;     &#125; &#125; .handle-container &#123;     display: flex;     margin-bottom: 16px; &#125; .zn-content &#123;     display: flex;     flex-direction: column;     height: 100%;     flex: 1;     overflow: auto;     background-color: #fff;     box-sizing: border-box;     padding: 14px;     &gt; .zn-content &#123;         padding-left: 0;         padding-right: 0;     &#125; &#125; .text-a-c &#123;     text-align: center; &#125; .text-a-l &#123;     text-align: left; &#125; .text-a-r &#123;     text-align: right; &#125;</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大量数据渲染优化</title>
      <link href="/2021/01/17/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/"/>
      <url>/2021/01/17/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h5 id="项目需求，消息列表，数量太大，并且是不断更新消息，类似于-QQ-消息列表，可能达到十万条，dom-渲染太多，浏览器卡爆，"><a href="#项目需求，消息列表，数量太大，并且是不断更新消息，类似于-QQ-消息列表，可能达到十万条，dom-渲染太多，浏览器卡爆，" class="headerlink" title="项目需求，消息列表，数量太大，并且是不断更新消息，类似于 QQ 消息列表，可能达到十万条，dom 渲染太多，浏览器卡爆，"></a>项目需求，消息列表，数量太大，并且是不断更新消息，类似于 QQ 消息列表，可能达到十万条，dom 渲染太多，浏览器卡爆，</h5><p>最后根据只渲染少数可视范围内的元素的思路</p><pre><code>&lt;div @scroll=&quot;newMessageListScroll&quot;&gt;    &lt;div :style=&quot;&#123;height: trueHeight + &#39;px&#39;&#125;&quot;&gt;        // key设置为index时diff算法不会销毁创建外部元素        &lt;li v-for&quot;(item, index) in showNewMessageList :key=&quot;index&quot;            .slice(lazyFirstIndex,lazyFirstIndex + lazyShowNumber)&quot;            :style=&quot;&#123; transform: `translateY($&#123;lazyFirstIndex * itemHeight&#125;px)` &#125;&quot;        &gt;&lt;/li&gt;        ...    &lt;/div&gt;&lt;/div&gt;</code></pre><p>定义父元素高度</p><pre><code>data()&#123;    return&#123;        trueHeight：0 // 父元素真实高度        lazyFirstIndex: 0 // 显示的首个元素的下标        lazyShowNumber: 20 // 显示数量        itemHeight:64 // 子元素高度    &#125;&#125;</code></pre><p>初始化时</p><pre><code>this.lazyShowNumber = Math.ceil(window.innerHeight / itemHeight);</code></pre><p>初始化和更新消息列表时</p><pre><code>this.trueHeight = messageList.length * itemHeight; // height为子元素的高度</code></pre><p>滚动消息列表时调用</p><pre><code>newMessageListScroll()&#123;  const &#123; scrollTop &#125; = e.target;  this.lazyFirstIndex = Math.floor(scrollTop / itemHeight);&#125;</code></pre><p>利用作用域插槽继续封装为简单的 vue 组件<br>long-list/index.vue</p><pre><code>    &lt;template&gt;        &lt;div id=&quot;long-list&quot; class=&quot;long-list&quot; @scroll=&quot;longListScroll&quot;&gt;            &lt;div :style=&quot;&#123; height: trueHeight + &#39;px&#39; &#125;&quot;&gt;            &lt;div :style=&quot;&#123; transform: `translateY($&#123;firstIndex * itemHeight&#125;px)` &#125;&quot;&gt;                &lt;slot                v-bind:data=&quot;dataArray.slice(firstIndex, firstIndex + showNumber)&quot;                &gt;&lt;/slot&gt;            &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;    export default &#123;    props: &#123;        dataArray: &#123;        type: Array,        default: () =&gt; [],        &#125;,        itemHeight: &#123;        type: Number,        default: () =&gt; 0,        &#125;,    &#125;,    computed: &#123;        trueHeight() &#123;        return this.itemHeight * this.dataArray.length;        &#125;,    &#125;,    data() &#123;        return &#123;        firstIndex: 0,        showNumber: 20,        &#125;;    &#125;,    mounted() &#123;        this.init();    &#125;,    activated() &#123;        this.firstIndex = 0;    &#125;,    methods: &#123;        init() &#123;        const scrollDom = document.querySelector(&#39;#long-list&#39;);        const &#123; clientHeight &#125; = scrollDom;        this.showNumber = Math.ceil(clientHeight / this.itemHeight) + 4;        &#125;,        longListScroll(e) &#123;        const &#123; scrollTop &#125; = e.target;        this.firstIndex = Math.floor(scrollTop / this.itemHeight);        &#125;,    &#125;,    &#125;;    &lt;/script&gt;    &lt;style lang=&quot;scss&quot; scoped&gt;    .long-list &#123;    height: 100%;    overflow: auto;    &#125;    &lt;/style&gt;</code></pre><p>调用时</p><pre><code>&lt;long-list    v-if=&quot;isShowNewMessageList&quot;    class=&quot;user-list-container&quot;    :dataArray=&quot;showNewMessageList&quot;    :itemHeight=&quot;64&quot;&gt;    &lt;template v-slot=&quot;&#123; data &#125;&quot;&gt;        &lt;new-message-item            v-for=&quot;(item, index) in data&quot;            :key=&quot;index&quot; // 是用每条的id呢还是用index减少dom销毁新建，看自己            :data=&quot;item&quot;            :message-key=&quot;item.messageKey&quot;            :new-message-num=&quot;getNewMessageNum(item.messageKey)&quot;            class=&quot;pointer&quot;            @click.native=&quot;onClickItem(index, item.messageKey)&quot;        /&gt;    &lt;/template&gt;&lt;/long-list&gt;</code></pre><h5 id="缺陷："><a href="#缺陷：" class="headerlink" title="缺陷："></a>缺陷：</h5><pre><code>项的固定高度使用舒适，如果是内容项的高度需要自适应，还需要改进</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Javascript </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Window对象</title>
      <link href="/2020/12/28/Window%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/12/28/Window%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ol><li>btoa() 方法用于创建一个 base-64 编码的字符串。<br>该方法使用 “A-Z”, “a-z”, “0-9”, “+”, “/“ 和 “=” 字符来编码字符串。</li><li>base-64 解码使用方法是 atob() 。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js任务队列模拟</title>
      <link href="/2020/12/26/js%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F/"/>
      <url>/2020/12/26/js%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h5 id="朋友遇到一个面试题，让我试试，所以我试了下"><a href="#朋友遇到一个面试题，让我试试，所以我试了下" class="headerlink" title="朋友遇到一个面试题，让我试试，所以我试了下"></a>朋友遇到一个面试题，让我试试，所以我试了下</h5><p>实现一个任务队列，支持 N 个任务同时进行，超过 N 的任务处于等待状态，当一个任务结束时，自动开启等待中的任务(参考一些下载工具的下载任务逻辑)。<br>备注：任务是一个返回值是 Promise 的函数 Task: () =&gt; Promise<any>;</p><p>调用示例：<br>const taskQueue = new TaskQueue(2); // 2 表示只能同时执行两个任务<br>taskQueue.subscribe(task1);<br>taskQueue.subscribe(task2);<br>taskQueue.subscribe(task3);<br>taskQueue.subscribe(task4);</p><pre><code>    class TaskQueue &#123;        #count;        #taskList = [];        #waitList = [];        constructor(count) &#123;            this.#count = count;            setTimeout(this.#runTask.bind(this), 0);        &#125;        subscribe(task) &#123;            if (this.#check()) &#123;                this.#taskList.push(task);            &#125; else &#123;                this.#waitList.push(task);            &#125;        &#125;        #check() &#123;            return this.#taskList.length &lt; this.#count;        &#125;        #runTask() &#123;            if (this.#taskList.length === 0) return;            this.#taskList.forEach((i) =&gt; &#123;                try &#123;                    const task = this.#taskList.shift();                    task().then((value) =&gt; &#123;                        console.log(value);                    &#125;);                &#125; finally &#123;                    this.#moveTask();                    this.#runTask();                &#125;            &#125;);        &#125;        #moveTask() &#123;            if (this.#waitList.length === 0) return;            this.#taskList.push(this.#waitList.shift());        &#125;    &#125;    // 测试下    const taskQueue = new TaskQueue(2);    const task = (index) =&gt; &#123;        return new Promise((resolve, reject) =&gt; &#123;            setTimeout(() =&gt; &#123;                resolve(`task：$&#123;index&#125;，$&#123;new Date().getTime()&#125;`);            &#125;, 2000)        &#125;);    &#125;;    for (let index = 0; index &lt; 8; index++) &#123;        taskQueue.subscribe(task.bind(this, index));    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex随记</title>
      <link href="/2020/12/22/vuex%E9%9A%8F%E8%AE%B0/"/>
      <url>/2020/12/22/vuex%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li>mapState 不生效问题<br>mapState 只能映射 store 的根状态树，modules 内的状态不映射</li></ol>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的js（上卷）</title>
      <link href="/2020/12/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89/"/>
      <url>/2020/12/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分：作用域和闭包"><a href="#第一部分：作用域和闭包" class="headerlink" title="第一部分：作用域和闭包"></a>第一部分：作用域和闭包</h2><h3 id="第-1-章：作用域是什么"><a href="#第-1-章：作用域是什么" class="headerlink" title="第 1 章：作用域是什么"></a>第 1 章：作用域是什么</h3><p>大部分语言编译器编译原理:<br>① 分词/词法分析<br>② 解析/语法分析<br>③ 代码生成<br>LHS 查询：变量出现在左侧时，<br>RHS 查询：所有非左侧时</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会示用 LHS 查询，如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。<br>2、JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤；</p><ol><li> 首先，var a 在其作用域中声明新变量，这会在最开始的阶段，也就是代码执行前进行。</li><li> 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。</li></ol><p>3、LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或没找到都将停止。<br>4、不成功的 RHS 引用会导致抛出 Reference Error 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 Reference Error 异常（严格模式下）。<br>5、嵌套的作用域为作用域链，最终指向全局作用域 window</p><h3 id="第-2-章：词法作用域"><a href="#第-2-章：词法作用域" class="headerlink" title="第 2 章：词法作用域"></a>第 2 章：词法作用域</h3><p>作用域查找：<br>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者向上进行，直到遇见第一个匹配的标识符为止。<br>全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。<br>欺骗词法：<br>欺骗词法作用域会导致性能下降<br>eval(…)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就在于程序中这个位置的代码；严格模式 eval(…)在运行时有其字的词法作用域，无法修改其所在的作用域。<br>with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。<br>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段<br>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它进行查找。<br>JavaScript 中有两个机制可以“欺骗”词法作用域：eval(…)和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象和属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是运行时）。<br>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h3 id="第-3-章：函数作用域和块作用域"><a href="#第-3-章：函数作用域和块作用域" class="headerlink" title="第 3 章：函数作用域和块作用域"></a>第 3 章：函数作用域和块作用域</h3><h4 id="函数中的作用域"><a href="#函数中的作用域" class="headerlink" title="函数中的作用域"></a>函数中的作用域</h4><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。<br>但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题。<br>区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置。）如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。它们之间最重要的区别是它们的名称标识符将会绑定在何处。</p><h4 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h4><p>可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”他们<br><strong>规避冲突</strong>：“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。<br><strong>1. 全局命名空间：</strong>在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。<br><strong>2. 模块管理：</strong>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中。而是通过依赖管理器的机制将库的标识符现世显式地导入到另外一个特定的作用域中。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。<br>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{…}内部）。<br>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。<br>在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if(…){let a =2;} 会声明一个劫持了 if 的{…}块的变量，并且将变量添加到这个块中。<br>有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同步存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读，可维护的优良代码。</p><h4 id="匿名和具名函数"><a href="#匿名和具名函数" class="headerlink" title="匿名和具名函数"></a>匿名和具名函数</h4><p>函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。<br>匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它也有几个缺点需要考虑：</p><ol><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ol><p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。</p><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><p>由于函数被包含在一对（）括号内部，因此成为了一个表达式，通过在末尾加上另外一个（）可以立即执行这个函数，比如（function foo（）{})()/第一个（）将函数变成表达式，第二个（）执行了这个函数。<br>改进的形式：(function(){}())。两种形式在功能上是一致的。<br>进阶用法：把它们当作函数调用并传递参数进去。<br>(function (global){…})(window)<br>还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在立即执行函数执行之后当作参数传递进去。</p><pre><code>(functionIIFE(def)&#123;  def(window);  &#125;)(functiondef(global)&#123;    vara=3;    console.log(a);//3    console.log(global.a);//2  &#125;);</code></pre><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不 “存在”。<br>函数是 JavaScript 中最常见的作用域单元。本质上，生命在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。<br>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅属于所处的作用域，也可以属于某个代码块（通常指{…}内部）。<br>从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。<br>从 ES6 中引入了 let 关键字（var 关键字的表亲），用来了在任意代码块中声明变量。if（…）{let a = 2；}会声明一个劫持了 if 的{…}块的变量，并且将变量添加到这个块中。</p><h3 id="第-4-章：提升"><a href="#第-4-章：提升" class="headerlink" title="第 4 章：提升"></a>第 4 章：提升</h3><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>我们习惯将 var a = 2;看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。<br>要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！<br>函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。<br>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p><h3 id="第-5-章：作用域闭包"><a href="#第-5-章：作用域闭包" class="headerlink" title="第 5 章：作用域闭包"></a>第 5 章：作用域闭包</h3><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。该函数对所在词法作用域的引用就叫做闭包</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><pre><code>functionCoolModule()&#123;  var something=&quot;cool&quot;;  var another=[1,2,3];  function doSomething()&#123;    console.log(something);  &#125;  function doAnother()&#123;    console.log(another.join(&quot;!&quot;));  &#125;  return &#123;    doSomething: doSomething,    doAnother: doAnother  &#125;;&#125;var foo = CoolModule();foo.doSomething();//coolfoo.doAnother();//1!2!3</code></pre><p>这个模式在 JavaScript 中被称为模块。</p><ol><li> 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li> 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><p>单例模式：</p><pre><code>var foo = (function CoolModule()&#123;    var something=&quot;cool&quot;;    var another=[1,2,3];    function doSomething()&#123;      console.log(something);    &#125;    function doAnother()&#123;      console.log(another.join(&quot;!&quot;));    &#125;    return &#123;      doSomething: doSomething,      doAnother: doAnother    &#125;;  &#125;)();  foo.doSomething();//cool  foo.doAnother();//1!2!3</code></pre><h4 id="现代的模块机制"><a href="#现代的模块机制" class="headerlink" title="现代的模块机制"></a>现代的模块机制</h4><pre><code>var MyModules = (function Manager() &#123;  var modules = &#123;&#125;  function define(name, deps, impl) &#123;    for (var i = 0; i &lt; deps.length; i++) &#123;      deps[i] = modules[deps[i]]    &#125;    modules[name] = impl.apply(impl, deps)  &#125;  function get(name) &#123;    return modules[name]  &#125;  return &#123; define, get &#125;&#125;)()MyModules.define(&#39;bar&#39;, [], function () &#123;  function hello(who) &#123;    return &#39;Letmeintroduce:&#39; + who  &#125;  return &#123; hello &#125;&#125;)MyModules.define(&#39;foo&#39;, [&#39;bar&#39;], function (bar) &#123;  var hungry = &#39;hippo&#39;  function awesome() &#123;    console.log(bar.hello(hungry).toUpperCase())  &#125;  return &#123; awesome &#125;&#125;)var bar = MyModules.get(&#39;bar&#39;)var foo = MyModules.get(&#39;foo&#39;)console.log(bar.hello(&#39;hippo&#39;)) //Let me introduce: hippofoo.awesome();foo.awesome() //LETMEINTRODUCE:HIPPO</code></pre><h4 id="未来的模块机制"><a href="#未来的模块机制" class="headerlink" title="未来的模块机制"></a>未来的模块机制</h4><p>ES6 中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6 会将文件当作独立的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。<br>ES6 的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）。浏览器或引擎有一个默认的“模块加载器”可以在导入模块时异步地加载模块文件。<br>import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是 hello）。module 会将整个模块的 API 导入并绑定到一个变量上（在我们的例子里是 foo 和 bar）。export 会将当前模块的一个标识符（变量、函数）导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。<br>模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。</p><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。<br>模块有两个主要特征：<br>（1）为创建内部作用域而调用了一个包装函数；<br>（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</p><h2 id="第二部分：this-和对象原型"><a href="#第二部分：this-和对象原型" class="headerlink" title="第二部分：this 和对象原型"></a>第二部分：this 和对象原型</h2><h3 id="第-1-章：关于-this"><a href="#第-1-章：关于-this" class="headerlink" title="第 1 章：关于 this"></a>第 1 章：关于 this</h3><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>this 既不指向函数自身也不指向函数的词法作用域。<br>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p><h3 id="第-2-章：this-全面解析"><a href="#第-2-章：this-全面解析" class="headerlink" title="第 2 章：this 全面解析"></a>第 2 章：this 全面解析</h3><h4 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h4><p>调用位置就是函数在代码中被调用的位置（而不是声明的位置）</p><h4 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h4><p>1、默认绑定<br>独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。<br>2、隐式绑定<br>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。<br>3、显式绑定<br>通过 call(..)或者 apply(..)或者 bind(..)<br>4、new 绑定<br>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的 this。</li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li></ol><p>使用 new 来调用 foo(..)时，我们会构造一个新对象并把它绑定到 foo(..)调用中的 this 上。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ol><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。<br>var bar = new foo()</li><li>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。<br>var bar = foo.call(obj2)</li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。<br>var bar = obj1.foo()</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。<br>var bar = foo()</li></ol><h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><ol><li><p>被忽略的 this<br> 使用 null 来忽略 this 绑定可能产生一些副作用。<br> 安全用法：Object.create(null)和{}很像，但是并不会创建 Object.prototype 这个委托，所以它比{}“更空”</p></li><li><p>间接引用</p><pre><code> function foo() &#123;   console.log(this.a); &#125; var a = 2; var o = &#123; a: 3, foo: foo &#125;; var p = &#123; a: 4 &#125;; o.foo(); //3 (p.foo = o.foo)(); //2</code></pre><p> 赋值表达式 p.foo=o.foo 的返回值是目标函数的引用，因此调用位置是 foo()而不是 p.foo()或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。</p></li><li><p>软绑定</p><pre><code> if (!Function.prototype.softBind) &#123;   Function.prototype.softBind = function (obj) &#123;     var fn = this //捕获所有curried参数     var curried = [].slice.call(arguments, 1)     var bound = function () &#123;       return fn.apply(         !this || this === (window || global)           ? obj           : this.curried.concat.apply(curried, arguments)       )     &#125;     bound.prototype = Object.create(fn.prototype)     return bound   &#125; &#125; function foo() &#123;   console.log(&#39;name:&#39; + this.name) &#125; var obj = &#123; name: &#39;obj&#39; &#125;,   obj2 = &#123; name: &#39;obj2&#39; &#125;,   obj3 = &#123; name: &#39;obj3&#39; &#125; var fooOBJ = foo.softBind(obj) fooOBJ() //name:obj obj2.foo = foo.softBind(obj) obj2.foo() //name:obj2&lt;----看！！！ fooOBJ.call(obj3) //name:obj3&lt;----看！ setTimeout(obj2.foo, 10) //name:obj&lt;----应用了软绑定</code></pre><p> 可以看到，软绑定版本的 foo()可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj。</p></li></ol><h4 id="this-词法"><a href="#this-词法" class="headerlink" title="this 词法"></a>this 词法</h4><p>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p><ol><li>由 new 调用？绑定到新创建的对象。</li><li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。</li><li>由上下文对象调用？绑定到那个上下文对象。</li><li>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</li></ol><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø=Object.create(null)，以保护全局对象。<br>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。</p><h3 id="第-3-章：对象"><a href="#第-3-章：对象" class="headerlink" title="第 3 章：对象"></a>第 3 章：对象</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>对象可以通过两种形式定义：声明（文字）形式和构造形式。</p><p>文字语法</p><pre><code>var myObj=&#123;    key: value    //...&#125;;</code></pre><p>构造形式</p><pre><code>var myObj = newObject();myObj.key = value;</code></pre><p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个键/值对，但是在构造形式中你必须逐个添加属性。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象是 JavaScript 的基础。在 JavaScript 中一共有六种主要类型（术语是“语言类型”）：</p><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ul><p>原理是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”</p><h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>在 JavaScript 中，它们实际上只是一些内置函数。这些内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象。<br>typeof 以上 为’function’</p><pre><code>var strPrimitive = &#39;Iamastring&#39; // 字面量typeof strPrimitive //&quot;string&quot;strPrimitive instanceof String //falsevar strObject = new String(&#39;Iamastring&#39;)typeof strObject //&quot;object&quot;strObject instanceof String //true//检查sub-type对象Object.prototype.toString.call(strObject) //[object String]</code></pre><p>引擎自动把字面量转换成 String 对象，所以可以访问属性和方法。</p><p>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</p><p>对于 Object、Array、Function 和 RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>1、可计算属性名<br>ES6 增加了可计算属性名，可以在文字形式中使用[]包裹一个表达式来当作属性名</p><p>2、属性与方法<br>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象——它们只是对于相同函数对象的多个引用。<br>每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定 this<br>3、数组<br>4、复制对象<br>深复制：JSON.parse(JSON.stringify(someObj))<br>ES6 定义了 Object.assign(..)方法来实现浅复制。由于 Object.assign(..)就是使用=操作符来赋值，所以源对象属性的一些特性（比如 writable）不会被复制到目标对象。<br>5、属性描述符<br>从 ES5 开始，所有的属性都具备了属性描述符。</p><pre><code>var myObject = &#123;      a: 2    &#125;;Object.getOwnPropertyDescriptor(myObject,&quot;a&quot;);//&#123;  //value: 2,  //writable: true, 决定是否可以修改属性的值。  //enumerable: true,  只要属性是可配置的，就可以使用defineProperty(..)方法  来修改属性描述符把configurable修改成false是单向操作，无法撤销！  //configurable: true 属性是否会出现在对象的属性枚举中//&#125;</code></pre><p>这个普通的对象属性对应的属性描述符（也被称为“数据描述符”，因为它只保存一个数据值）可不仅仅只是一个 2。它还包含另外三个特性：writable（可写）、enumerable（可枚举）和 configurable（可配置）。即便属性是 configurable:false，我们还是可以把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，configurable:false 还会禁止删除这个属性</p><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 Object.defineProperty(..)来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置。</p><p>6、不变性</p><ol><li><p>对象常量<br> 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）</p></li><li><p>禁止扩展<br> Object.preventExtensions(myObject);</p><pre><code>  var myObject = &#123;      a:2  &#125;;  Object.preventExtensions(myObject);  myObject.b=3;  myObject.b;//undefined</code></pre></li><li><p>密封<br> Object.seal(..)会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..)并把所有现有属性标记为 configurable:false。所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）。</p></li><li><p>冻结<br> Object.freeze(..)会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..)并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。</p><p> 这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..)，然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。</p></li></ol><p>7、[[Get]]<br>对象默认的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。<br>如果没有找到名称相同的属性则遍历可能存在的[[Prototype]]链，也就是原型链。无论如何都没有找到名称相同的属性，那[[Get]]操作会返回值 undefined</p><p>8、[[Put]]<br>[[Put]]算法大致会检查下面这些内容。</p><ol><li>属性是否是访问描述符（参见 3.3.9 节）？如果是并且存在 setter 就调用 setter。</li><li>属性的数据描述符中 writable 是否是 false？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li><li>如果都不是，将该值设置为属性的值。</li></ol><p>如果对象中不存在这个属性，[[Put]]操作会更加复杂。</p><p>9、Getter 和 Setter<br>对象默认的[[Put]]和[[Get]]操作分别可以控制属性值的设置和获取。<br>在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏函数，会在设置属性值时调用。</p><p>10、存在性</p><pre><code>var myObject= &#123;    a: 2&#125;;(&quot;a&quot;inmyObject);//true(&quot;b&quot;inmyObject);//falsemyObject.hasOwnProperty(&quot;a&quot;);//truemyObject.hasOwnProperty(&quot;b&quot;);//false</code></pre><p>in 操作符会检查属性是否在对象及其[[Prototype]]原型链中。相比之下，hasOwnProperty(..)只会检查属性是否在 myObject 对象中，不会检查[[Prototype]]链。</p><p>所有的普通对象都可以通过对于 Object.prototype 的委托来访问 hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 Object.create(null)来创建）。在这种情况下，形如 myObejct.hasOwnProperty(..)就会失败。这时可以使用一种更加强硬的方法来进行判断：Object.prototype.hasOwnProperty.call(myObject,”a”)，它借用基础的 hasOwnProperty(..)方法并把它显式绑定到 myObject 上</p><ol><li><p>枚举</p><pre><code> var myObject=&#123;&#125;; Object.defineProperty(   myObject,   &quot;a&quot;,//让a像普通属性一样可以枚举   &#123;enumerable:true,value:2&#125; ); Object.defineProperty(   myObject,   &quot;b&quot;,//让 b 不可枚举   &#123;enumerable:false,value:3&#125; ); myObject.propertyIsEnumerable(&quot;a&quot;);//true myObject.propertyIsEnumerable(&quot;b&quot;);//false Object.keys(myObject);//[&quot;a&quot;] Object.getOwnPropertyNames(myObject);//[&quot;a&quot;,&quot;b&quot;]</code></pre></li></ol><p>propertyIsEnumerable(..)会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true。<br>Object.keys(..)会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。<br>in 和 hasOwnProperty(..)的区别在于是否查找[[Prototype]]链，然而，Object.keys(..)和 Object.getOwnPropertyNames(..)都只会查找对象直接包含的属性。</p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>JavaScript 中的对象有字面形式（比如 vara={..}）和构造形式（比如 vara=newArray(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。<br>对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签[objectArray]表示这是对象的子类型数组。<br>对象就是键/值对的集合。可以通过.propName 或者[“propName”]语法来获取属性值。访问属性时，引擎实际上会调用内部的默认[[Get]]操作（在设置属性值时是[[Put]]），[[Get]]操作会检查对象本身是否包含这个属性，如果没找到的话还会查找[[Prototype]]链（参见第 5 章）。<br>是对象的子类型数组。<br>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..)和 Object.freeze(..)来设置对象（及其属性）的不可变性级别。<br>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。<br>可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of 会寻找内置或者自定义的@@iterator 对象并调用它的 next()方法来遍历数据值。</p><h3 id="第-4-章：混合对象“类”"><a href="#第-4-章：混合对象“类”" class="headerlink" title="第 4 章：混合对象“类”"></a>第 4 章：混合对象“类”</h3><h4 id="类理论"><a href="#类理论" class="headerlink" title="类理论"></a>类理论</h4><p>类/继承描述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript 也有类似的语法，但是和其他语言中的类完全不同。<br>类意味着复制。<br>传统中的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。<br>多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是子类引用父类，但是本质上引用的其实是复制的结果。<br>JavaScript 并不会（像类那样）自动创建对象的副本。<br>混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显示伪多态（OtherObj.methodName.call(this,…)），这会让代码更加难懂并且难以维护。<br>此外，显式混入实际上无法完全模拟类的复制行为，因为对象（和函数！别忘了函数也是对象）只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。<br>总的来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。</p><h3 id="第-5-章：原型"><a href="#第-5-章：原型" class="headerlink" title="第 5 章：原型"></a>第 5 章：原型</h3><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h4><p>JavaScript 中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。<br>当你通过各种语法进行属性查找时都会查找[[Prototype]]链，直到找到属性或者查找完整条原型链。</p><p>1、Object.prototype<br>所有普通的[[Prototype]]链最终都会指向内置的 Object.prototype。<br>2、属性设置和屏蔽<br>如果属性名 foo 既出现在 myObject 中也出现在 myObject 的[[Prototype]]链上层，那么就会发生屏蔽。myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。<br>如果 foo 不直接存在于 myObject 中而是存在于原型链上层时 myObject.foo=”bar”会出现的三种情况。</p><ol><li>如果在[[Prototype]]链上层存在名为 foo 的普通数据访问属性并且没有被标记为只读（writable:false），那就会直接在 myObject 中添加一个名为 foo 的新属性，它是屏蔽属性。</li><li>如果在[[Prototype]]链上层存在 foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在 myObject 上创建屏蔽属性（这个限制只存在于=赋值中，使用 Object.defineProperty(..)并不会受到影响。）。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li><li>如果在[[Prototype]]链上层存在 foo 并且它是一个 setter（参见第 3 章），那就一定会调用这个 setter。foo 不会被添加到（或者说屏蔽于）myObject，也不会重新定义 foo 这个 setter。</li></ol><h4 id="“类”"><a href="#“类”" class="headerlink" title="“类”"></a>“类”</h4><p>在 JavaScript 中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行为。再说一遍，JavaScript 中只有对象。<br>1、“类”函数<br>2、“构造函数”<br>函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”<br>3、技术<br>实际上，对象的.constructor 会默认指向一个函数，这个函数可以通过对象的.prototype 引用。“constructor”和“prototype”这两个词本身的含义可能适用也可能不适用。最好的办法是记住这一点“constructor 并不表示被构造”。<br>.constructor 并不是一个不可变属性。它是不可枚举的，但是它的值是可写的（可以被修改）。此外，你可以给任意[[Prototype]]链中的任意对象添加一个名为 constructor 的属性或者对其进行修改，你可以任意对其赋值。<br>.constructor 是一个非常不可靠并且不安全的引用。通常来说要尽量避免使用这些引用。</p><h4 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h4><p>Bar.prototype=Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。因此当你执行类似 Bar.prototype.myLabel=…的赋值语句时会直接修改 Foo.prototype 对象本身。显然这不是你想要的结果，否则你根本不需要 Bar 对象，直接使用 Foo 就可以了，这样代码也会更简单一些。<br>Bar.prototype=newFoo()的确会创建一个关联到 Bar.prototype 的新对象。但是它使用了 Foo(..)的“构造函数调用”，如果函数 Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给 this 添加数据属性，等等）的话，就会影响到 Bar()的“后代”，后果不堪设想。</p><p>因此，要创建一个合适的关联对象，我们必须使用 Object.create(..)而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p><p><strong>ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联。</strong></p><p>对比一下两种把 Bar.prototype 关联到 Foo.prototype 的方法：</p><pre><code>//ES6之前需要抛弃默认的Bar.prototypeBar.ptototype=Object.create(Foo.prototype);//ES6开始可以直接修改现有的Bar.prototypeObject.setPrototypeOf(Bar.prototype,Foo.prototype);</code></pre><p>如果忽略掉 Object.create(..)方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比 ES6 及其之后的方法更短而且可读性更高。</p><p><strong>检查“类关系”</strong><br>instanceof 操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof 回答的问题是：在 a 的整条[[Prototype]]链中是否有指向 Foo.prototype 的对象？<br>这个方法只能处理对象（a）和函数（带.prototype 引用的 Foo）之间的关系。如果你想判断两个对象（比如 a 和 b）之间是否通过[[Prototype]]链关联，只用 instanceof 无法实现。</p><pre><code>//第二种判断[[Prototype]]反射的方法Foo.prototype.isPrototypeOf(a);//true</code></pre><p>isPrototypeOf(..)回答的问题是：在 a 的整条[[Prototype]]链中是否出现过 Foo.prototype？<br>这个方法并不需要使用函数（“类”），它直接使用 b 和 c 之间的对象引用来判断它们的关系。换句话说，语言内置的 isPrototypeOf(..)函数就是我们的 isRelatedTo(..)函数。</p><pre><code>//非常简单：b是否出现在c的[[Prototype]]链中？b.isPrototypeOf(c);</code></pre><p>也可以直接获取一个对象的[[Prototype]]链。在 ES5 中，标准的方法是：</p><pre><code>Object.getPrototypeOf(a);</code></pre><p>可以验证一下，这个对象引用是否和我们想的一样：</p><pre><code>Object.getPrototypeOf(a)===Foo.prototype;//true</code></pre><p>绝大多数（不是所有！）浏览器也支持一种非标准的方法来访问内部[[Prototype]]属性：</p><pre><code>a.**proto**===Foo.prototype;//true</code></pre><p>.__proto__的实现大致上是这样的</p><pre><code>Object.defineProperty(Object.prototype, &quot;__proto__&quot; ,&#123;    get: function() &#123;        return Object.getPrototypeOf(this);    &#125;,    set: function(o) &#123;        //ES6中的setPrototypeOf(..)        Object.setPrototypeOf(this,o);        return o;    &#125;&#125;);</code></pre><p>访问（获取值）a.<strong>proto</strong>时，实际上是调用了 a.<strong>proto</strong>()（调用 getter 函数）。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a（this 的绑定规则参见第 2 章），所以和 Object.getPrototypeOf(a)结果相同。<br>.__proto__是可设置属性，之前的代码中使用 ES6 的 Object.setPrototypeOf(..)进行设置。然而，通常来说你不需要修改已有对象的[[Prototype]]。</p><h4 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h4><p>Object.create(null)会创建一个拥有空（或者说 null）[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符（之前解释过）无法进行判断，因此总是会返回 false。这些特殊的空[[Prototype]]对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p><p>Object.create(..)是在 ES5 中新增的函数,Object.create()的 polyfill 代码</p><pre><code>if(!Object.create)&#123;    Object.create = function(o) &#123;        function F() &#123;&#125;        F.prototype = o;      return new F();    &#125;;&#125;</code></pre><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p>如果要访问对象中并不存在的一个属性，[[Get]]操作就会查找对象内部[[Prototype]]关联的对象。这个关联关系实际上定义了一条“原型链”（有点像嵌套的作用域链），在查找属性时会对它进行遍历。</p><p>所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止。toString()、valueOf()和其他一些通用的功能都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。</p><p>关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的四个步骤中会创建一个关联其他对象的新对象。</p><p>使用 new 调用函数时会把新对象的.prototype 属性关联到“其他对象”。带 new 的函数调用通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。</p><p>虽然这些 JavaScript 机制和传统面向类语言中的“类初始化”和“类继承”很相似，但是 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象直接是通过内部的[[Prototype]]链关联的。</p><p>出于各种原因，以“继承”结尾的术语（包括“原型继承”）和其他面向对象的术语都无法帮助你理解 JavaScript 的真实机制（不仅仅是限制我们的思维模式）。<br>相比之下，“委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。</p><h3 id="第-6-章：行为委托"><a href="#第-6-章：行为委托" class="headerlink" title="第 6 章：行为委托"></a>第 6 章：行为委托</h3><h4 id="面向委托的设计"><a href="#面向委托的设计" class="headerlink" title="面向委托的设计"></a>面向委托的设计</h4><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p>在软件架构中你可以选择是否使用类和继承设计模式。大多数开发者理所当然地认为类是唯一（合适）的代码组织方式，但是本章中我们看到了另一种更少见但是更强大的设计模式：行为委托。<br>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的[[Prototype]]机制本质上就是行为委托机制。也就是说，我们可以选择在 JavaScript 中努力实现类机制，也可以拥抱更自然的[[Prototype]]委托机制。</p><p>当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。</p><p>对象关联（对象之前互相关联）是一种编码风格，它倡导的是直接创建和关联对象，不把他们抽象成类。对象关联可以用基于[[Prototype]]的行为委托非常自然地实现。</p><h3 id="ES6-中的-Class"><a href="#ES6-中的-Class" class="headerlink" title="ES6 中的 Class"></a>ES6 中的 Class</h3><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><p>class 很好地伪装成 JavaScript 中类和继承设计模式的解决方案，但是它实际上起到了反作用：它隐藏了许多问题并且带来了更多更细小但是危险的问题。<br>class 加深了过去 20 年中对于 JavaScript 中“类”的误解，在某些方面，它产生的问题比解决的多，而且让本来优雅简洁的[[Prototype]]机制变得非常别扭。<br>结论：如果 ES6 的 class 让[[Prototype]]变得更加难用而且隐藏了 JavaScript 对象最重要的机制——对象之间的实时委托关联，我们难道不应该认为 class 产生的问题比解决的多吗？难道不应该抵制这种设计模式吗？</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gogs+hexo搭建自己的git私服且自动部署博客网站</title>
      <link href="/2019/12/26/gogs-hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84git%E7%A7%81%E6%9C%8D%E4%B8%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2019/12/26/gogs-hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84git%E7%A7%81%E6%9C%8D%E4%B8%94%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h5 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h5><pre><code># 通过yum源安装dockeryum -y install docker# 启动dockersystemctl start docker# 开机自启sudo systemctl enable docker</code></pre><h5 id="下载-gogs-的-docker-镜像"><a href="#下载-gogs-的-docker-镜像" class="headerlink" title="下载 gogs 的 docker 镜像"></a>下载 gogs 的 docker 镜像</h5><pre><code>docker pull gogs/gogs</code></pre><h5 id="创建-gogs-存储的目录"><a href="#创建-gogs-存储的目录" class="headerlink" title="创建 gogs 存储的目录"></a>创建 gogs 存储的目录</h5><pre><code>mkdir -p /var/gogs</code></pre><h5 id="运行镜像-产生容器"><a href="#运行镜像-产生容器" class="headerlink" title="运行镜像, 产生容器"></a>运行镜像, 产生容器</h5><pre><code>docker run --name=gogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs</code></pre><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><pre><code>通过浏览器访问公网 ip 地址:10080</code></pre><h5 id="注册登录后创建新仓库"><a href="#注册登录后创建新仓库" class="headerlink" title="注册登录后创建新仓库"></a>注册登录后创建新仓库</h5><pre><code>并在仓库设置内→管理Git钩子→post-receiven，改动后更新钩子设置#!/usr/bin/env bashunset $(git rev-parse --local-env-vars);cd /data/hexo-blog/; // 容器内的路径git pull origin master;</code></pre><h5 id="测试钩子是否生效"><a href="#测试钩子是否生效" class="headerlink" title="测试钩子是否生效"></a>测试钩子是否生效</h5><pre><code>cd /var/gogs/git/gogs-repositories/zhangnan/hexo-blog.git/custom_hooks/[root@VM-0-11-centos custom_hooks]# lspost-receive[root@VM-0-11-centos custom_hooks]# ./post-receive</code></pre><h5 id="本地-Hexo-项目"><a href="#本地-Hexo-项目" class="headerlink" title="本地 Hexo 项目"></a>本地 Hexo 项目</h5><pre><code>_config.yml内deploy:    type: git    repo:        github: git@github.com:zn-nz/zn-nz.github.io.git        laycoder: http://laycoder.com:10080/zhangnan/hexo-blog.git // gogs博客仓库地址    branch: master</code></pre><h5 id="上传一次后，到想放的文件夹内-git-clone"><a href="#上传一次后，到想放的文件夹内-git-clone" class="headerlink" title="上传一次后，到想放的文件夹内 git clone"></a>上传一次后，到想放的文件夹内 git clone</h5><pre><code>cd /var/gogsgit clone http://laycoder.com:10080/zhangnan/hexo-blog.git// 给git用户权限chown –R git:git /var/gogs/hexo-bloggit config credential.helper store  // 登录一次后，后续可免密登录或在.git下的config内[remote &quot;origin&quot;]        url = http://&#123;user&#125;:&#123;password&#125;@laycoder.com:10080/zhangnan/hexo-blog.git        fetch = +refs/heads/*:refs/remotes/origin/*</code></pre><h5 id="正常的-Nginx-web-服务器"><a href="#正常的-Nginx-web-服务器" class="headerlink" title="正常的 Nginx web 服务器"></a>正常的 Nginx web 服务器</h5><pre><code>listen       443 ssl;server_name  www.laycoder.com;ssl_certificate      1_www.laycoder.com_bundle.crt;ssl_certificate_key  2_www.laycoder.com.key;ssl_session_cache    shared:SSL:1m;ssl_session_timeout  5m;ssl_ciphers  ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;ssl_prefer_server_ciphers  on;location / &#123;    root   /var/gogs/hexo-blog; // 宿主真实路径    index  index.html index.htm;    try_files $uri $uri/ /index.html;&#125;</code></pre><h5 id="后续本地发布时，自动部署到自己的目录下"><a href="#后续本地发布时，自动部署到自己的目录下" class="headerlink" title="后续本地发布时，自动部署到自己的目录下"></a>后续本地发布时，自动部署到自己的目录下</h5>]]></content>
      
      
      
        <tags>
            
            <tag> Gogs </tag>
            
            <tag> Hexo </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组排序</title>
      <link href="/2019/05/28/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/05/28/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>冒泡排序</li></ol><pre><code>function sort(arr)&#123;  for(let i = 0; i &lt; arr.length - 1; i++) &#123;    for(let j = 0; j &lt; arr.length - i - 1; j++) &#123;      if(arr[j] &gt; arr[j + 1]) &#123;        const temp = arr[j];        arr[j] = arr[j + 1];        arr[j + 1] = temp;      &#125;    &#125;  &#125;&#125;</code></pre><ol start="2"><li>快速排序</li></ol><pre><code>function quickSort(arr)&#123;  if(arr.length &lt;= 1 ) &#123;    return arr;  &#125;  const pivotIndex = Math.floor(arr.length / 2);  const pivot = arr.splice(pivotIndex, 1)[0];  const left = [];  const right = [];  for(let i = 0; i &lt; arr.length; i++) &#123;    if(arr[i] &lt; pivot) &#123;      left.push(arr[i])    &#125; else &#123;      right.push(arr[i])    &#125;  &#125;  return [...quickSort(left), pivot, ...quickSort(right)];&#125;</code></pre><ol start="3"><li>Array.sort</li></ol><pre><code>arr.sort((a, b) =&gt; b - a)</code></pre><ol start="4"><li>一层的json数组排序</li></ol><pre><code>// 匹配中文const REGCHINESENUM = /[一二三四五六七八九十]&#123;1,&#125;/;// 匹配汉字const REGCH = /^[\u4e00-\u9fa5]+$/;// 是否是汉字const isCH= str =&gt; REGCH.test(str);/*** 一层json数组排序* @param &#123;[&#123;&#125;]&#125; arr* @param &#123;string&#125; keys // 按多个key排序英文逗号,隔开* @param &#123;boolean&#125; big2Small // 是否从大到小排，默认false——从小到大* @returns*/const sortFuc = (arr, keys, big2Small = false) =&gt; &#123;  if (Object.prototype.toString.call(arr) !== &quot;[object Array]&quot;) return [];  const keyArr = keys?.split(&quot;,&quot;);  function computeResult(av, bv) &#123;    switch (true) &#123;    case !!av?.match(REGCHINESENUM)?.length &amp;&amp; !!bv?.match(REGCHINESENUM)?.length:      return chineseToNumber(av?.match(REGCHINESENUM)[0]) - chineseToNumber(bv?.match(REGCHINESENUM)[0]);    case isCH(av) &amp;&amp; isCH(bv):      return -1;    case isCH(av) &amp;&amp; !isCH(bv):      return -1;    case !isCH(av) &amp;&amp; isCH(bv):      return 1;    default:      break;    &#125;    let temp = 0;    if (av?.length !== bv?.length) &#123;      temp += av?.length - bv?.length || 0;    &#125; else &#123;      temp += av?.localeCompare(bv) + ((av - bv) * 2 || 0);    &#125;    return temp;  &#125;  return arr.sort((a, b) =&gt; &#123;    let result = 0;    if (keyArr) &#123;      keyArr.forEach((key) =&gt; &#123;        try &#123;          const av = a[key]?.toString().trim();          const bv = b[key]?.toString().trim();          result += computeResult(av, bv);        &#125; catch (e) &#123;          console.log(e);        &#125;      &#125;);    &#125; else &#123;      const av = a?.toString().trim();      const bv = b?.toString().trim();      result += computeResult(av, bv);    &#125;    return result * (big2Small ? -1 : 1);  &#125;);&#125;;// 中文数字转换阿拉伯数字const chnNumChar = &#123;  零: 0,  一: 1,  二: 2,  三: 3,  四: 4,  五: 5,  六: 6,  七: 7,  八: 8,  九: 9&#125;;const chnNameValue = &#123;  十: &#123; value: 10, secUnit: false &#125;,  百: &#123; value: 100, secUnit: false &#125;,  千: &#123; value: 1000, secUnit: false &#125;,  万: &#123; value: 10000, secUnit: true &#125;,  亿: &#123; value: 100000000, secUnit: true &#125;&#125;;function chineseToNumber(chnStr) &#123;  var rtn = 0;  var section = 0;  var number = 0;  var secUnit = false;  var str = chnStr.split(&quot;&quot;);  for (var i = 0; i &lt; str.length; i++) &#123;    var num = chnNumChar[str[i]];    if (typeof num !== &quot;undefined&quot;) &#123;      number = num;      if (i === str.length - 1) &#123;        section += number;      &#125;    &#125; else &#123;      var unit = chnNameValue[str[i]].value;      secUnit = chnNameValue[str[i]].secUnit;      if (secUnit) &#123;        section = (section + number) * unit;        rtn += section;        section = 0;      &#125; else &#123;        section += number * unit;      &#125;      number = 0;    &#125;  &#125;  return rtn + section;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计稿rem换算</title>
      <link href="/2019/02/28/%E8%AE%BE%E8%AE%A1%E7%A8%BFrem%E6%8D%A2%E7%AE%97/"/>
      <url>/2019/02/28/%E8%AE%BE%E8%AE%A1%E7%A8%BFrem%E6%8D%A2%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>rem 是相对于根元素的字体大小的单位<br>rem 是 CSS3 新增的一个相对单位（root em，根 em），这个单位引起了广泛关注。这个单位与 em 有什么区别呢？区别在于使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用 rem 设定的字体大小。</p><p>根据设计稿参照<br>如 iPhone6 375x667</p><p>屏幕宽为 100vw<br>每像素的 vw<br>100vw / 375px（设计稿尺寸） = 0.2667vw;<br>为了方便计算取每 100px 的 vw 设置为根元素单位<br>100px = 26.67vw<br>1rem 等于一个根元素单位<br>1rem = 26.67vw = 100px =<br>设计稿一般为 750px 则<br>html 根元素设置 font-size</p><pre><code>html&#123;  font-size:13.33vw;&#125;</code></pre><p>页面 css 使用时将设计稿的像素值/100=rem 数值</p>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http协议</title>
      <link href="/2019/02/20/http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/02/20/http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="一-说一下什么是-Http-协议"><a href="#一-说一下什么是-Http-协议" class="headerlink" title="一.说一下什么是 Http 协议"></a>一.说一下什么是 Http 协议</h5><p>对器客户端和 服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”。</p><h5 id="二-什么是-Http-协议无状态协议-怎么解决-Http-协议无状态协议"><a href="#二-什么是-Http-协议无状态协议-怎么解决-Http-协议无状态协议" class="headerlink" title="二.什么是 Http 协议无状态协议?怎么解决 Http 协议无状态协议?"></a>二.什么是 Http 协议无状态协议?怎么解决 Http 协议无状态协议?</h5><p>(1)、无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息<br>(2)、无状态协议解决办法： 通过 1、Cookie 2、通过 Session 会话保存。</p><h5 id="三-Http-协议由什么组成"><a href="#三-Http-协议由什么组成" class="headerlink" title="三.Http 协议由什么组成?"></a>三.Http 协议由什么组成?</h5><p>请求报文包括三部分:<br>(1).请求行:包含请求方法,URI,HTTP 版本协议<br>(2).请求首部字段<br>(3).请求内容实体<br>响应报文包含三部分:<br>(1).状态行:包含 HTTP 版本,状态码,状态码原因短语<br>(2).响应首部字段<br>(3).响应内容实体</p><p>http 请求由三部分组成，分别是：请求行、消息报头、请求正文<br>HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于 TCP 的连接方式，HTTP1.1 版本中给出一种持续连接的机制，绝大多数的 Web 开发，都是构建在 HTTP 协议之上的 Web 应用。<br>1、常用的 HTTP 方法有哪些？<br>GET、POST、PUT、HEAD、DELETE、OPTIONS<br>GET： 用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器。<br>POST：用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。<br>PUT： 传输文件，报文主体中包含文件内容，保存到对应 URI 位置。<br>HEAD： 获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。<br>DELETE：删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。<br>OPTIONS：查询相应 URI 支持的 HTTP 方法。</p><p>2、GET 方法与 POST 方法的区别</p><ul><li>get 重点在从服务器上获取资源，post 重点在向服务器发送数据；</li><li>get 传输数据是通过 URL 请求，以 field（字段）= value 的形式，置于 URL 后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%94%A8%E6%88%B7%E6%98%AF%E5%8F%AF%E8%A7%81%E7%9A%84%EF%BC%9Bpost%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%80%9A%E8%BF%87Http%E7%9A%84post%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%B0%86%E5%AD%97%E6%AE%B5%E4%B8%8E%E5%AF%B9%E5%BA%94%E5%80%BC%E5%B0%81%E5%AD%98%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BD%93%E4%B8%AD%E5%8F%91%E9%80%81%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%AF%B9%E7%94%A8%E6%88%B7%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%A7%81%E7%9A%84%EF%BC%9B">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</a></li><li>Get 传输的数据量小，因为受 URL 长度限制，但效率较高；Post 可以传输大量数据，所以上传文件时只能用 Post 方式</li><li>get 是不安全的，因为 URL 是可见的，可能会泄露私密信息，如密码等；post 较 get 安全性较高</li><li>get 方式只能支持 ASCII 字符，向服务器传的中文字符可能会乱码；post 支持标准字符集，可以正确传递中文字符。</li></ul><p>3、HTTP 请求报文与响应报文格式<br>请求报文包含三部分：<br>a、请求行：包含请求方法、URI、HTTP 版本信息<br>b、请求首部字段<br>c、请求内容实体<br>响应报文包含三部分：<br>a、状态行：包含 HTTP 版本、状态码、状态码的原因短语<br>b、响应首部字段<br>c、响应内容实体</p><p>4、常见的 HTTP 相应状态码<br>返回的状态<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>200：请求被正常处理<br>204：请求被受理但没有资源可以返回<br>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行 GET 方法，相应报文中通过 Content-Range 指定范围的资源。<br>301：永久性重定向<br>302：临时重定向<br>303：与 302 状态码有相似功能，只是它希望客户端在请求一个 URI 的时候，能通过 GET 方法重定向到另一个 URI 上<br>304：发送附带条件的请求时，条件不满足时返回，与重定向无关<br>307：临时重定向，与 302 类似，只是强制要求使用 POST 方法<br>400：请求报文语法有误，服务器无法识别<br>401：请求需要认证<br>403：请求的对应资源禁止被访问<br>404：服务器无法找到对应资源<br>500：服务器内部错误<br>503：服务器正忙<br>5、HTTP1.1 版本新特性<br>a、默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开 TCP 连接，就一直保持连接，可以发送多次 HTTP 请求<br>b、管线化，客户端可以同时发出多个 HTTP 请求，而不用一个个等待响应<br>c、断点续传原理</p><p>6、常见 HTTP 首部字段<br>a、通用首部字段（请求报文与响应报文都会使用的首部字段）<br>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式<br>b、请求首部字段（请求报文会使用的首部字段）<br>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言<br>c、响应首部字段（响应报文会使用的首部字段）<br>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的 URI<br>Server：HTTP 服务器的安装信息<br>d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）<br>Allow：资源可支持的 HTTP 方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p><p>7、HTTP 的缺点与 HTTPS<br>a、通信使用明文不加密，内容可能被窃听<br>b、不验证通信方身份，可能遭到伪装<br>c、无法验证报文完整性，可能被篡改<br>HTTPS 就是 HTTP 加上 SSL 加密处理（一般是 SSL 安全通信线路）+认证+完整性保护<br>https 的 SSL 过程<br>客户端浏览器在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。<br><img src="/imgs/http%E5%8D%8F%E8%AE%AE/1.png"><br>（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。<br>（2）Web 服务器收到客户端请求后，会生成一对公钥和私钥，并把公钥放在证书中发给客户端浏览器。<br>（3）客户端浏览器根据双方同意的 SSL 连接的安全等级，建立会话密钥，然后用公钥将会话密钥加密，并传送给服务器。<br>（4）Web 服务器用自己的私钥解密出会话密钥。<br>（5）Web 服务器利用会话密钥加密与客户端之间的通信。</p><p>8、HTTP 优化<br>利用负载均衡优化和加速 HTTP 应用<br>利用 HTTP Cache 来优化网站</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下mysql安装</title>
      <link href="/2019/01/20/Linux%E4%B8%8Bmysql%E5%AE%89%E8%A3%85/"/>
      <url>/2019/01/20/Linux%E4%B8%8Bmysql%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>去官网下载 Yum 资源包，下载地址为：<a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a></p><p>wget <a href="http://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm">http://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm</a></p><p>rpm -ivh mysql*<strong>*****</strong>.rpm<br>yum update<br>yum install mysql-server</p><p>权限设置：<br>chown mysql:mysql -R /var/lib/mysql<br>初始化 MySQL：<br>mysqld –initialize<br>启动 MySQL：<br>systemctl start mysqld<br>查看 MySQL 运行状态：<br>systemctl status mysqld</p><p>【修改密码】</p><ol><li>刚刚启动成功之后, 用命令查看默认密码并且登录<br>　　　　查看：cat /var/log/mysqld.log | grep password<br>　　　　登陆：mysql -u root -p 然后输入密码</li><li>修改密码<br>　　　　 set global validate_password.policy=0;<br>　　　　 set global validate_password.length=1;<br>　　　　 ALTER USER “root”@”localhost” IDENTIFIED BY “1234”; // 新密码为 1234<br>　　　　远程连接时要替换成 ALTER USER “root”@”%” IDENTIFIED BY “1234”;)</li><li>exit 退出 mysql -u root -p 然后输入密码即可登录<br>【授权远程访问】<br>　　首先确保关闭了防火墙 并重启 mysql。<br>　　 1. 选择数据库 use mysql show tables;可以看到很多表<br>　　 2. 修改连接规则：host 表示允许哪个 ip 来连接，user 表示哪个数据库。例如 mysql –uroot –p 连的就是叫 root 数据库。<br>　　 3. 查看规则 select host,user from user \G; 修改规则 update user set host= ‘%’ where user = ‘root’;</li><li>mysql5.7.6 之后就修改了加密规则，我这里是 mysql8.0.12 所以需要更改加密方式。<br>　　　 update user set plugin=’mysql_native_password’ where user =’root’;<br>　　 5. 刷新权限 flush privileges;<br>　　 6. 测试外网连接 mysql 服务器。<br>　　 (如果外网连接失败的话，先按照【重置密码】执行一遍，再执行【修改密码】，只是 ALTER USER “root”@”localhost” IDENTIFIED BY “1234”;要替换成 ALTER USER “root”@”%” IDENTIFIED BY “1234”;)</li></ol><p>【重置密码】</p><ol><li>开启免密码登陆 修改 my.cnf 文件 默认在/etc/my.cnf。<br>　　　　 vim /etc/my.cnf 在【mysqld】模块下面添加：skip-grant-tables 保存退出。</li><li>重启服务，使配置生效 。 service mysqld restart</li><li>登陆 mysql -u root -p //不输入密码直接敲回车键</li><li>选择数据库 use mysql 把密码置空(因为免密登陆时不能直接修改密码)<br>　　　　 update user set authentication_string = ‘’ where user = ‘root’;</li><li>退出 quit 把/etc/my.cnf 免密删掉。 重启服务 service mysqld restart</li><li>登陆 mysql -u root -p //直接敲回车键，因为刚刚置空密码了。</li><li>和上面修改密码的步骤一样，重复一遍就好了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运用pm2</title>
      <link href="/2019/01/20/%E8%BF%90%E7%94%A8pm2/"/>
      <url>/2019/01/20/%E8%BF%90%E7%94%A8pm2/</url>
      
        <content type="html"><![CDATA[<p>Installing PM2<br>With NPM:</p><pre><code>    $ npm install pm2 -g</code></pre><p>Or if you don’t have Node.js installed:</p><pre><code>    wget -qO- https://getpm2.com/install.sh | bash</code></pre><p>Start an application<br>You can start any application (Node.js, Python, Ruby, binaries in $PATH…) like that:</p><pre><code>    $ pm2 start app.js</code></pre><p>Your app is now daemonized, monitored and kept alive forever.<br>More about Process Management<br>Managing Applications<br>Once applications are started you can manage them easily:</p><p>To list all running applications:</p><pre><code>    $ pm2 list</code></pre><p>Managing apps is straightforward:</p><pre><code>    $ pm2 stop &lt;app_name|namespace|id|&#39;all&#39;|json_conf&gt;    $ pm2 restart &lt;app_name|namespace|id|&#39;all&#39;|json_conf&gt;    $ pm2 delete &lt;app_name|namespace|id|&#39;all&#39;|json_conf&gt;</code></pre><p>To have more details on a specific application:</p><pre><code>    $ pm2 describe &lt;id|app_name&gt;</code></pre><p>To monitor logs, custom metrics, application information:</p><pre><code>    $ pm2 monit</code></pre><p>More about Application Management<br>Cluster Mode: Node.js Load Balancing &amp; Zero Downtime Reload<br>The Cluster mode is a special mode when starting a Node.js application, it starts multiple processes and load-balance HTTP/TCP/UDP queries between them. This increase overall performance (by a factor of x10 on 16 cores machines) and reliability (faster socket re-balancing in case of unhandled errors).<br>Starting a Node.js application in cluster mode that will leverage all CPUs available:</p><pre><code>    $ pm2 start api.js -i &lt;processes&gt;</code></pre><p>&lt;processes&gt; can be ‘max’, -1 (all cpu minus 1) or a specified number of instances to start.<br>Zero Downtime Reload<br>Hot Reload allows to update an application without any downtime:</p><pre><code>    $ pm2 reload all</code></pre><p>Seamlessly supported by all major Node.js frameworks and any Node.js applications without any code change:<br>More informations about how PM2 make clustering easy<br>Container Support<br>With the drop-in replacement command for node, called pm2-runtime, run your Node.js application in a hardened production environment. Using it is seamless:<br>RUN npm install pm2 -g<br>CMD [ “pm2-runtime”, “npm”, “–”, “start” ]</p><p>Read More about the dedicated integration<br>Terminal Based Monitoring<br>Monitor all processes launched straight from the command line:</p><pre><code>    $ pm2 monit</code></pre><p>Log Management<br>To consult logs just type the command:</p><pre><code>    $ pm2 logs</code></pre><p>Standard, Raw, JSON and formated output are available.<br>Examples:</p><pre><code>    $ pm2 logs APP-NAME # Display APP-NAME logs    $ pm2 logs --json # JSON output    $ pm2 logs --format # Formated output    $ pm2 flush # Flush all logs    $ pm2 reloadLogs # Reload all logs</code></pre><p>More about log management<br>Startup Scripts Generation<br>PM2 can generates and configure a Startup Script to keep PM2 and your processes alive at every server restart.<br>Init Systems Supported: systemd, upstart, launchd, rc.d</p><h1 id="Generate-Startup-Script"><a href="#Generate-Startup-Script" class="headerlink" title="Generate Startup Script"></a>Generate Startup Script</h1><pre><code>    $ pm2 startup</code></pre><h1 id="Freeze-your-process-list-across-server-restart"><a href="#Freeze-your-process-list-across-server-restart" class="headerlink" title="Freeze your process list across server restart"></a>Freeze your process list across server restart</h1><pre><code>    $ pm2 save</code></pre><h1 id="Remove-Startup-Script"><a href="#Remove-Startup-Script" class="headerlink" title="Remove Startup Script"></a>Remove Startup Script</h1><pre><code>    $ pm2 unstartup</code></pre><p>More about Startup Scripts Generation<br>PM2 Modules<br>PM2 embeds a simple and powerful module system. Installing a module is straightforward:</p><pre><code>    $ pm2 install &lt;module_name&gt;</code></pre><p>Here are some PM2 compatible modules (standalone Node.js applications managed by PM2):<br>pm2-logrotate automatically rotate logs and limit logs size<br>pm2-server-monit monitor the current server with more than 20+ metrics and 8 actions<br>Updating PM2</p><h1 id="Install-latest-PM2-version"><a href="#Install-latest-PM2-version" class="headerlink" title="Install latest PM2 version"></a>Install latest PM2 version</h1><pre><code>    $ npm install pm2@latest -g</code></pre><h1 id="Save-process-list-exit-old-PM2-amp-restore-all-processes"><a href="#Save-process-list-exit-old-PM2-amp-restore-all-processes" class="headerlink" title="Save process list, exit old PM2 &amp; restore all processes"></a>Save process list, exit old PM2 &amp; restore all processes</h1><pre><code>    $ pm2 update</code></pre><p>PM2 updates are seamless</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pm2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上安装nvm</title>
      <link href="/2019/01/20/Linux%E5%AE%89%E8%A3%85nvm/"/>
      <url>/2019/01/20/Linux%E5%AE%89%E8%A3%85nvm/</url>
      
        <content type="html"><![CDATA[<p>第一步安装</p><p>curl -o- <a href="https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh">https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh</a> | bash</p><p>第二步</p><p>export NVM_DIR=”${XDG_CONFIG_HOME/:-$HOME/.}nvm”<br>[ -s “$NVM_DIR/nvm.sh” ] &amp;&amp; . “$NVM_DIR/nvm.sh” # This loads nvm</p><p>第三步：</p><p>nvm –version</p><p>出现版本号表示安装成功<br>安装 node<br>安装 node</p><p>nvm install v10.16.0</p><p>nvm use 版本号<br>nvm alias default v*<em>.**.\</em> 更改默认开机版本</p><p>若下载不了<br>则用 git clone<br>cd nvm<br>./install.sh</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2019/01/04/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/01/04/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h5 id="查看、添加、提交、删除、找回、重置修改文件"><a href="#查看、添加、提交、删除、找回、重置修改文件" class="headerlink" title="查看、添加、提交、删除、找回、重置修改文件"></a>查看、添加、提交、删除、找回、重置修改文件</h5><p>显示 command 的 help<br>git help &lt;command&gt;<br>显示某次提交的内容 git show $id<br>git show<br>抛弃工作区修改<br>git checkout – &lt;file&gt;&gt;<br>抛弃工作区修改<br>git checkout .<br>将工作文件修改提交到本地缓存区<br>git add &lt;file&gt;<br>将所有修改过的工作文件提交缓存区<br>git add .<br>从版本库中删除文件<br>git rm &lt;file&gt;<br>从版本库中删除文件,但不删除文件<br>git rm &lt;file&gt; –cached<br>从暂存区恢复到工作文件<br>git reset &lt;file&gt;<br>从暂存区恢复但工作文件<br>git reset – .<br>回复最近一次提交过的状态，即放弃上次提交后的所有修改<br>git reset –hard<br>提交已经跟踪过的修改<br>git commit -am “some comments”<br>修改最后一次提交记录<br>git commit –amend<br>将 git add,git rm 和 git commit 等操作都合并在一起做<br>git commit &lt;file&gt; git commit . git commit -a<br>恢复某次提交的状态，恢复动作本身也创建次提交对象<br>git revert &lt;$id&gt;<br>恢复最后一次提交的状态<br>git revert HEAD</p><h5 id="git-本地分支管理"><a href="#git-本地分支管理" class="headerlink" title="git 本地分支管理"></a>git 本地分支管理</h5><p>查看远程分支<br>git branch -r<br>查看所有分支<br>git branch -a<br>创建新的分支<br>git branch &lt;branch&gt;<br>查看各个分支最后提交信息<br>git branch -v<br>查看已经被合并到当前分支的分支<br>git branch –merged<br>查看尚未被合并到当前分支的分支<br>git branch –no-merged<br>切换到某个分支<br>git checkout &lt;branch&gt;<br>创建新的分支，并且切换过去<br>git checkout -b &lt;branch&gt;<br>基于 branch 创建新的 new_branch<br>git checkout -b &lt;new_branch&gt; &lt;branch&gt;<br>把某次历史提交记录 checkout 出来，但无分支信息，切换到其他分支会自动删除<br>git checkout $id<br>把某次历史提交记录 checkout 出来，创建一个分支<br>git checkout $id -b &lt;branch&gt;<br>删除某个分支<br>git branch -d &lt;branch&gt;<br>强制删除某个分支（未被合并的分支被删除的时候需要强制）<br>git branch -D &lt;branch&gt;</p><h5 id="分支合并和-rebase"><a href="#分支合并和-rebase" class="headerlink" title="分支合并和 rebase"></a>分支合并和 rebase</h5><p>将 branch 分支合并到当前分支<br>git merge &lt;branch&gt;<br>不要 fast-foward 合并，这样可以生成 merge 提交<br>git merge origin/master –no-ff<br>将 master rebase 到 branch<br>git rebase master &lt;branch&gt;<br>git checkout &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branch&gt;<br>合并冲突全部选择他们的版本<br>git merge –strategy-option theirs<br>合并冲突全部选择我们的版本<br>git merge –strategy-option ours</p><h5 id="git-远程分支管理"><a href="#git-远程分支管理" class="headerlink" title="git 远程分支管理"></a>git 远程分支管理</h5><p>抓取远程仓库所有分支更新并合并到本地<br>git pull<br>抓取远程仓库所有分支更新并合并到本地，不要快速合并<br>git pull –no-ff<br>抓取远程仓库更新<br>git fetch origin<br>将远程主分支合并到本地当前分支<br>git merge origin/master<br>跟踪某个远程分支创建相应的本地分支<br>git checkout –track origin/branch<br>基于远程分支创建本地分支<br>git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;<br>push 所有分支<br>git push<br>将本地主分支推到远程主分支<br>git push origin master<br>将本地主分支推到远程未创建的分支<br>git push -u origin master<br>创建远程分支，origin 是远程仓库代称<br>git push origin &lt;local_branch&gt;<br>创建远程分支<br>git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;<br>先删除本地分支（git branch -d &lt;branch&gt;)，然后再 push 删除远程分支<br>git push origin:&lt;remote_branch&gt;</p><h5 id="git-远程仓库管理"><a href="#git-远程仓库管理" class="headerlink" title="git 远程仓库管理"></a>git 远程仓库管理</h5><p>查看远程服务器地址和仓库代称<br>git remote -v<br>查看远程服务器仓库状态<br>git remote show origin<br>添加远程仓库地址<br>git remote add origin &lt;url&gt;<br>设置远程仓库地址<br>git remote set-url origin &lt;url&gt;<br>删除远程仓库<br>git remote rm &lt;仓库代称&gt;</p><h5 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h5><p>设置远程仓库的 HEAD 指向 master 分支<br>git remote set-head origin master<br>设置本地库跟踪远程库<br>git branch –set-upstream master origin/master</p><h5 id="查看文件-diff"><a href="#查看文件-diff" class="headerlink" title="查看文件 diff"></a>查看文件 diff</h5><p>比较当前文件和暂存区文件差异<br>git diff &lt;file&gt;<br>比较两次提交之间的差异<br>git diff &lt;id1&gt; &lt;id2&gt;<br>在两个分支之间比较<br>git diff &lt;branch1&gt; &lt;branch2&gt;<br>比较暂存区和版本库差异<br>git diff –staged<br>git diff –cached<br>仅仅比较统计信息<br>git diff –stat</p><h5 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h5><p>查看该文件每次提交记录<br>git log &lt;file&gt;<br>查看每次详细修改内容的 diff<br>git log -p &lt;file&gt;<br>查看最近两次详细修改内容的 diff<br>git log -p -2<br>查看提交统计信息<br>git log –stat</p><h5 id="git-补丁管理（方便在多台机器上开发同步时-用）"><a href="#git-补丁管理（方便在多台机器上开发同步时-用）" class="headerlink" title="git 补丁管理（方便在多台机器上开发同步时 用）"></a>git 补丁管理（方便在多台机器上开发同步时 用）</h5><p>生成补丁<br>git diff &gt; ../sync.patch<br>打补丁<br>git apply ../sync.patch<br>测试补丁能否成功<br>git apply –check ../sync.patch</p><h5 id="git-暂存管理"><a href="#git-暂存管理" class="headerlink" title="git 暂存管理"></a>git 暂存管理</h5><p>暂存<br>git stash<br>列出所有 stash<br>git stash list<br>恢复暂存的内容<br>git stash apply<br>删除暂存区<br>git stash drop</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器信息</title>
      <link href="/2018/12/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/12/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<ol><li><p>window<br>表示浏览器的窗口。<br>有 innerWidth 和 innerHeight 这两个属性。可以获取浏览器的内部宽高。<br>window.innerWidth;<br>window.innerHeight;<br>对应的还有 outWidth 和 outHeight 这两个属性，获取浏览器窗口的整体的宽高。<br>window.outerWidth;<br>window.outerHeight;</p></li><li><p>navigator<br>表示浏览器信息。<br>navigator.appName:浏览器名称；<br>navigator.appVersion:浏览器版本<br>navigator.language:浏览器设置的语言<br>navigator.platform：操作系统类型；<br>navigator.userAgent:浏览器设定的 Use-Agent 字符串</p></li><li><p>screen<br>表示屏幕信息。<br>screen.width; //屏幕宽度<br>screen.height; //屏幕宽度<br>screen.colorDepth; //颜色位数</p></li><li><p>location<br>表示当前页面的 URL 信息。<br>location.href; //获取当前页面 URL 整体信息</p></li><li><p>document<br>表示当前的页面信息。<br>还可以获取当前页面的 Cookie 信息。<br>document.cookie;</p></li><li><p>history<br>表示页面的历史纪录。<br>但在任何情况下不使用该对象。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js引擎的执行过程（二）</title>
      <link href="/2018/12/25/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/12/25/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="js-引擎的执行过程（二）"><a href="#js-引擎的执行过程（二）" class="headerlink" title="js 引擎的执行过程（二）"></a><center>js 引擎的执行过程（二）</center></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>js 引擎执行过程主要分为三个阶段，分别是语法分析，预编译和执行阶段，上篇文章我们介绍了语法分析和预编译阶段，那么我们先做个简单概括，如下：<br>语法分析： 分别对加载完成的代码块进行语法检验，语法正确则进入预编译阶段；不正确则停止该代码块的执行，查找下一个代码块并进行加载，加载完成再次进入该代码块的语法分析阶段<br>预编译：通过语法分析阶段后，进入预编译阶段，则创建变量对象（创建 arguments 对象（函数运行环境下），函数声明提前解析，变量声明提升），确定作用域链以及 this 指向。<br>如还有疑问回头看看上篇文章 js 引擎的执行过程（一）。</p><p>本文主要分析 js 引擎执行的第三个阶段–执行阶段，在分析之前我们先思考以下两个问题：<br>js 是单线程的，为了避免代码解析阻塞使用了异步执行，那么它的异步执行机制是怎么样的？<br>通过事件循环（Event Loop），理解了事件循环的原理就理解了 js 的异步执行机制，本文主要介绍。<br>js 是单线程的，那么是否代表参与 js 执行过程的线程就只有一个？<br>不是的，会有四个线程参与该过程，但是永远只有 JS 引擎线程在执行 JS 脚本程序，其他的三个线程只协助，不参与代码解析与执行。参与 js 执行过程的线程分别是：<br>JS 引擎线程： 也称为 JS 内核，负责解析执行 Javascript 脚本程序的主线程（例如 V8 引擎）<br>事件触发线程： 归属于浏览器内核进程，不受 JS 引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数推进事件队列，等待 JS 引擎线程执行<br>定时器触发线程：主要控制计时器 setInterval 和延时器 setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列中，等待 JS 引擎线程执行。<br>注：W3C 在 HTML 标准中规定 setTimeout 低于 4ms 的时间间隔算为 4ms。<br>HTTP 异步请求线程：通过 XMLHttpRequest 连接后，通过浏览器新开的一个线程，监控 readyState 状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待 JS 引擎线程执行。<br>注：浏览器对通一域名请求的并发连接数是有限制的，Chrome 和 Firefox 限制数为 6 个，ie8 则为 10 个。<br>总结：永远只有 JS 引擎线程在执行 JS 脚本程序，其他三个线程只负责将满足触发条件的处理函数推进事件队列，等待 JS 引擎线程执行。<br>执行阶段<br>我们先分析一个典型的例子（来自 Tasks, microtasks, queues and schedules，建议英文基础好的阅读，非常不错的文章）：<br>console.log(‘script start’);setTimeout(function() { console.log(‘setTimeout’);}, 0);Promise.resolve().then(function() { console.log(‘promise1’);}).then(function() { console.log(‘promise2’);});console.log(‘script end’);<br>这里我直接划分例子的代码结构，简单描述分析执行过程，暂不解释该过程中的概念和原理，概念和原理将会在下面具体讲解如下：<br>宏任务（macro-task），宏任务又按执行顺序分为同步任务和异步任务<br>同步任务<br>console.log(‘script start’);console.log(‘script end’);<br>异步任务<br>setTimeout(function() { console.log(‘setTimeout’);}, 0);<br>微任务（micro-task）<br>Promise.resolve().then(function() { console.log(‘promise1’);}).then(function() { console.log(‘promise2’);});<br>在 JS 引擎执行过程中，进入执行阶段后，代码的执行顺序如下：<br>宏任务(同步任务) –&gt; 微任务 –&gt; 宏任务(异步任务)<br>输出结果为：<br>script startscript endpromise1promise2setTimeout<br>进入 ES6 或 Node 环境中，JS 的任务分为两种，分别是宏任务（macro-task）和微任务（micro-task），在最新的 ECMAScript 中，微任务称为 jobs，宏任务称为 task，他们的执行顺序如上。可能很多人对上面的分析并不理解，那么我们接下来继续对上面例子进行详细分析。<br>宏任务<br>宏任务（macro-task）可分为同步任务和异步任务：<br>同步任务指的是在 JS 引擎主线程上按顺序执行的任务，只有前一个任务执行完毕后，才能执行后一个任务，形成一个执行栈（函数调用栈）。<br>异步任务指的是不直接进入 JS 引擎主线程，而是满足触发条件时，相关的线程将该异步任务推进任务队列(task queue)，等待 JS 引擎主线程上的任务执行完毕，空闲时读取执行的任务，例如异步 Ajax，DOM 事件，setTimeout 等。<br>理解宏任务中同步任务和异步任务的执行顺序，那么就相当于理解了 JS 异步执行机制–事件循环（Event Loop）。<br>事件循环<br>事件循环可以理解成由三部分组成，分别是：<br>主线程执行栈<br>异步任务等待触发<br>任务队列<br>任务队列(task queue)就是以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出。</p><p>这里直接引用一张著名的图片(参考自 Philip Roberts 的演讲《Help, I’m stuck in an event-loop》)，帮助我们理解，如下：</p><p>在 JS 引擎主线程执行过程中：<br>首先执行宏任务的同步任务，在主线程上形成一个执行栈，可理解为函数调用栈；<br>当执行栈中的函数调用到一些异步执行的 API（例如异步 Ajax，DOM 事件，setTimeout 等 API），则会开启对应的线程（Http 异步请求线程，事件触发线程和定时器触发线程）进行监控和控制<br>当异步任务的事件满足触发条件时，对应的线程则会把该事件的处理函数推进任务队列(task queue)中，等待主线程读取执行<br>当 JS 引擎主线程上的任务执行完毕，则会读取任务队列中的事件，将任务队列中的事件任务推进主线程中，按任务队列顺序执行<br>当 JS 引擎主线程上的任务执行完毕后，则会再次读取任务队列中的事件任务，如此循环，这就是事件循环（Event Loop）的过程<br>如果还是不能理解，那么我们再次拿上面的例子进行详细分析，该例子中宏任务的代码部分是：<br>console.log(‘script start’);setTimeout(function() { console.log(‘setTimeout’);}, 0);console.log(‘script end’);<br>代码执行过程如下：<br>JS 引擎主线程按代码顺序执行，当执行到 console.log(‘script start’);，JS 引擎主线程认为该任务是同步任务，所以立刻执行输出 script start，然后继续向下执行；<br>JS 引擎主线程执行到 setTimeout(function() { console.log(‘setTimeout’); }, 0);，JS 引擎主线程认为 setTimeout 是异步任务 API，则向浏览器内核进程申请开启定时器线程进行计时和控制该 setTimeout 任务。由于 W3C 在 HTML 标准中规定 setTimeout 低于 4ms 的时间间隔算为 4ms，那么当计时到 4ms 时，定时器线程就把该回调处理函数推进任务队列中等待主线程执行，然后 JS 引擎主线程继续向下执行<br>JS 引擎主线程执行到 console.log(‘script end’);，JS 引擎主线程认为该任务是同步任务，所以立刻执行输出 script end<br>JS 引擎主线程上的任务执行完毕（输出 script start 和 script end）后，主线程空闲，则开始读取任务队列中的事件任务，将该任务队里的事件任务推进主线程中，按任务队列顺序执行，最终输出 setTimeout，所以输出的结果顺序为 script start script end setTimeout<br>以上便是 JS 引擎执行宏任务的整个过程。<br>理解该过程后，我们做一些拓展性的思考：<br>我们都知道 setTimeout 和 setInterval 是异步任务的定时器，需要添加到任务队列等待主线程执行，那么使用 setTimeout 模拟实现 setInterval，会有区别吗？<br>答案是有区别的，我们不妨思考一下：<br>setTimeout 实现 setInterval 只能通过递归调用<br>setTimeout 是在到了指定时间的时候就把事件推到任务队列中，只有当在任务队列中的 setTimeout 事件被主线程执行后，才会继续再次在到了指定时间的时候把事件推到任务队列，那么 setTimeout 的事件执行肯定比指定的时间要久，具体相差多少跟代码执行时间有关<br>setInterval 则是每次都精确的隔一段时间就向任务队列推入一个事件，无论上一个 setInterval 事件是否已经执行，所以有可能存在 setInterval 的事件任务累积，导致 setInterval 的代码重复连续执行多次，影响页面性能。<br>综合以上的分析，使用 setTimeout 实现计时功能是比 setInterval 性能更好的。当然如果不需要兼容低版本的 IE 浏览器，使用 requestAnimationFrame 是更好的选择。<br>我们继续再做进一步的思考，如下：<br>高频率触发的事件（例如滚动事件）触发频率过高会影响页面性能，甚至造成页面卡顿，我们是否可以利用计时器的原理进行优化呢？<br>是可以的，我们可以利用 setTimeout 实现计时器的原理，对高频触发的事件进行优化，实现点在于将多个触发事件合并成一个，这就是防抖和节流，本文先不做具体讲解，大家可以自行研究，有机会我再另开文章分析。<br>微任务<br>微任务是在 es6 和 node 环境中出现的一个任务类型，如果不考虑 es6 和 node 环境的话，我们只需要理解宏任务事件循环的执行过程就已经足够了，但是到了 es6 和 node 环境，我们就需要理解微任务的执行顺序了。<br>微任务（micro-task）的 API 主要有:Promise， process.nextTick<br>这里我们直接引用一张流程图帮助我们理解，如下：</p><p>在宏任务中执行的任务有两种，分别是同步任务和异步任务，因为异步任务会在满足触发条件时才会推进任务队列（task queue），然后等待主线程上的任务执行完毕，再读取任务队列中的任务事件，最后推进主线程执行，所以这里将异步任务即任务队列看作是新的宏任务。执行的过程如上图所示：<br>执行宏任务中同步任务，执行结束；<br>检查是否存在可执行的微任务，有的话执行所有微任务，然后读取任务队列的任务事件，推进主线程形成新的宏任务；没有的话则读取任务队列的任务事件，推进主线程形成新的宏任务<br>执行新宏任务的事件任务，再检查是否存在可执行的微任务，如此不断的重复循环<br>这就是加入微任务后的详细事件循环，如果还没有理解，那么们对一开始的例子做一个全面的分析，如下：<br>console.log(‘script start’);setTimeout(function() { console.log(‘setTimeout’);}, 0);Promise.resolve().then(function() { console.log(‘promise1’);}).then(function() { console.log(‘promise2’);});console.log(‘script end’);<br>执行过程如下：<br>代码块通过语法分析和预编译后，进入执行阶段，当 JS 引擎主线程执行到 console.log(‘script start’);，JS 引擎主线程认为该任务是同步任务，所以立刻执行输出 script start，然后继续向下执行；<br>JS 引擎主线程执行到 setTimeout(function() { console.log(‘setTimeout’); }, 0);，JS 引擎主线程认为 setTimeout 是异步任务 API，则向浏览器内核进程申请开启定时器线程进行计时和控制该 setTimeout 任务。由于 W3C 在 HTML 标准中规定 setTimeout 低于 4ms 的时间间隔算为 4ms，那么当计时到 4ms 时，定时器线程就把该回调处理函数推进任务队列中等待主线程执行，然后 JS 引擎主线程继续向下执行<br>JS 引擎主线程执行到 Promise.resolve().then(function() { console.log(‘promise1’); }).then(function() { console.log(‘promise2’); });，JS 引擎主线程认为 Promise 是一个微任务，这把该任务划分为微任务，等待执行<br>JS 引擎主线程执行到 console.log(‘script end’);，JS 引擎主线程认为该任务是同步任务，所以立刻执行输出 script end<br>主线程上的宏任务执行完毕，则开始检测是否存在可执行的微任务，检测到一个 Promise 微任务，那么立刻执行，输出 promise1 和 promise2<br>微任务执行完毕，主线程开始读取任务队列中的事件任务 setTimeout，推入主线程形成新宏任务，然后在主线程中执行，输出 setTimeout<br>最后的输出结果即为：<br>script startscript endpromise1promise2setTimeout<br>总结<br>以上便是 JS 引擎执行的全部过程，JS 引擎的执行过程其实并不复杂，只要多思考多研究就可以理解，理解该过程后可以在一定程度上提高对 JS 的认识。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js引擎的执行过程（一）</title>
      <link href="/2018/12/20/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/12/20/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="js-引擎的执行过程（一）"><a href="#js-引擎的执行过程（一）" class="headerlink" title="js 引擎的执行过程（一）"></a><center>js 引擎的执行过程（一）</center></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>js 是一种非常灵活的语言，理解 js 引擎的执行过程对我们学习 javascript 非常重要，但是网上讲解 js 引擎的文章也大多是浅尝辄止或者只局部分析，例如只分析事件循环（Event Loop）或者变量提升等等，并没有全面深入的分析其中过程。所以我一直想把 js 执行的详细过程整理成一个较为详细的知识体系，帮助我们理解和整体认识 js。<br>在分析之前我们先了解以下基础概念：</p><ul><li>javascript 是<strong>单线程语言</strong><br>在浏览器中一个页面永远只有一个线程在执行 js 脚本代码（在不主动开启新线程的情况下）。</li><li>javascript 是单线程语言,但是代码解析却十分的快速，不会发生解析阻塞。</li></ul><p>javascript 是异步执行的，通过<strong>事件循环（Event Loop）</strong>的方式实现。<br>下面我们先通过一段较为简单的代码（暂不存在事件循环（Event Loop））来检验我们对 js 引擎执行过程的理解是否正确，如下：</p><pre><code>    &lt;script&gt;        console.log(fun)        console.log(person)    &lt;/script&gt;    &lt;script&gt;        console.log(person)        console.log(fun)        var person = &quot;Eric&quot;;        console.log(person)        function fun() &#123;            console.log(person)            var person = &quot;Tom&quot;;            console.log(person)        &#125;        fun()        console.log(person)    &lt;/script&gt;</code></pre><p>我们可以先分析上面的代码，按自己的理解分析输出的顺序是什么，然后在浏览器执行一次，结果一样的话，那么代表你已经对 js 引擎执行过程有了正确的理解；如果不是，则代表还存在模糊或者概念不清晰等问题。结果我们不在这里进行讨论，我们利用上面简单的例子全面分析 js 引擎执行过程，相信在理解该过程后我们就不难得出结果的，js 引擎执行过程分为三个阶段：</p><ol><li><strong>语法分析</strong></li><li><strong>预编译阶段</strong></li><li><strong>执行阶段</strong></li></ol><p>注：浏览器首先按顺序加载由&lt;<strong>script</strong>&gt;标签分割的 js 代码块，加载 js 代码块完毕后，立刻进入以上三个阶段，然后再按顺序查找下一个代码块，再继续执行以上三个阶段，无论是外部脚本文件（不异步加载）还是内部脚本代码块，都是一样的原理，并且都在同一个全局作用域中。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>js 脚本代码块加载完毕后，会首先进入语法分析阶段。该阶段主要作用是：<br>分析该 js 脚本代码块的语法是否正确，如果出现不正确，则向外抛出一个语法错误（SyntaxError），停止该 js 代码块的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入预编译阶段<br>语法错误报错如下图：<br><img src="/imgs/js%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE1.jpeg"></p><h3 id="预编译阶段"><a href="#预编译阶段" class="headerlink" title="预编译阶段"></a>预编译阶段</h3><p>js 代码块通过语法分析阶段后，语法正确则进入预编译阶段。在分析预编译阶段之前，我们先了解一下 js 的运行环境，运行环境主要有三种：</p><ul><li><strong>全局环境</strong>（JS 代码加载完毕后，进入代码预编译即进入全局环境）</li><li><strong>函数环境</strong>（函数调用执行时，进入该函数环境，不同的函数则函数环境不同）</li><li><strong>eval</strong>（不建议使用，会有安全，性能等问题）</li></ul><p>每进入一个不同的运行环境都会创建一个相应的<strong>执行上下文（Execution Context）</strong>，那么在一段 JS 程序中一般都会创建多个执行上下文，js 引擎会以栈的方式对这些执行上下文进行处理，形成<strong>函数调用栈（call stack）</strong>，栈底永远是全局执行上下文（Global Execution Context），栈顶则永远是当前执行上下文。</p><h4 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h4><p>函数调用栈就是使用栈存取的方式进行管理运行环境，特点是<strong>先进后出，后进先出</strong>。<br>我们分析下段简单的 JS 脚本代码来理解函数调用栈：</p><pre><code>    function bar() &#123;    var B_context = &quot;Bar EC&quot;;    function foo() &#123;        var f_context = &quot;foo EC&quot;;    &#125;    foo();    &#125;    bar();</code></pre><p>上面的代码块通过语法分析后，进入预编译阶段，如下图：<br><img src="/imgs/js%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE2.png"></p><ol><li>首先进入全局环境，创建全局执行上下文（Global Execution Context），推入 stack 栈中</li><li>调用 bar 函数，进入 bar 函数运行环境，创建 bar 函数执行上下文（bar Execution Context），推入 stack 栈中</li><li>在 bar 函数内部调用 foo 函数，则再进入 foo 函数运行环境，创建 foo 函数执行上下文（foo Execution Context），推入 stack 栈中</li><li>此刻栈底是全局执行上下文（Global Execution Context），栈顶是 foo 函数执行上下文（foo Execution Context），如上图，由于 foo 函数内部没有再调用其他函数，那么则开始出栈</li><li>foo 函数执行完毕后，栈顶 foo 函数执行上下文（foo Execution Context）首先出栈</li><li>bar 函数执行完毕，bar 函数执行上下文（bar Execution Context）出栈</li><li>Global Execution Context 则在浏览器或者该标签页关闭时出栈。</li></ol><p>注：不同的运行环境执行都会进入代码预编译和执行两个阶段，语法分析则在代码块加载完毕时统一检验语法</p><h4 id="创建执行上下文"><a href="#创建执行上下文" class="headerlink" title="创建执行上下文"></a>创建执行上下文</h4><p>执行上下文可理解为当前的执行环境，与该运行环境相对应。创建执行上下文的过程中，主要做了以下三件事件，如图：<br><img src="/imgs/js%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE3.jpeg"><br><strong>1.创建变量对象（Variable Object）</strong><br><strong>2.建立作用域链（Scope Chain）</strong><br><strong>3.确定 this 的指向</strong></p><h4 id="创建变量对象"><a href="#创建变量对象" class="headerlink" title="创建变量对象"></a>创建变量对象</h4><p>创建变量对象主要经过以下几个过程，如图：<br><img src="/imgs/js%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE4.jpeg"></p><ol><li>创建 arguments 对象，检查当前上下文中的参数，建立该对象的属性与属性值，仅在函数环境(非箭头函数)中进行，全局环境没有此过程</li><li>检查当前上下文的函数声明，按代码顺序查找，将找到的函数提前声明，如果当前上下文的变量对象没有该函数名属性，则在该变量对象以函数名建立一个属性，属性值则为指向该函数所在堆内存地址的引用，如果存在，则会被新的引用覆盖。</li><li>检查当前上下文的变量声明，按代码顺序查找，将找到的变量提前声明，如果当前上下文的变量对象没有该变量名属性，则在该变量对象以变量名建立一个属性，属性值为 undefined；如果存在，则忽略该变量声明</li></ol><p>注：在全局环境中，window 对象就是全局执行上下文的变量对象，所有的变量和函数都是 window 对象的属性方法。<br>所以函数声明提前和变量声明提升是在创建变量对象中进行的，且函数声明优先级高于变量声明。<br>我们分析一段简单的代码，帮助我们理解该过程，如下：</p><pre><code>    function fun(a, b) &#123;    var num = 1;    function test() &#123;        console.log(num);    &#125;    &#125;    fun(2, 3);</code></pre><p>这里我们在全局环境调用 fun 函数，创建 fun 执行上下文，这里为了方便大家理解，暂时不讲解作用域链以及 this 指向，如下：</p><pre><code>    funEC = &#123;    //变量对象    VO: &#123;        //arguments对象        arguments: &#123;        a: undefined,        b: undefined,        length: 2,        &#125;,        //test函数        test: &lt;test reference&gt;,        //num变量        num: undefined,    &#125;,    //作用域链    scopeChain: [],    //this指向    this: window,    &#125;;</code></pre><ul><li>funEC 表示 fun 函数的执行上下文（fun Execution Context 简写为 funEC）</li><li>funE 的变量对象中 arguments 属性，上面的写法仅为了方便大家理解，但是在浏览器中展示是以类数组的方式展示的</li><li>&lt;test reference&gt;表示 test 函数在堆内存地址的引用</li></ul><p>注：创建变量对象发生在预编译阶段，但尚未进入执行阶段，该变量对象都是不能访问的，因为此时的变量对象中的变量属性尚未赋值，值仍为 undefined，只有进入执行阶段，变量对象中的变量属性进行赋值后，变量对象（Variable Object）转为活动对象（Active Object）后，才能进行访问，这个过程就是 VO –&gt; AO 过程。</p><h4 id="建立作用域链"><a href="#建立作用域链" class="headerlink" title="建立作用域链"></a>建立作用域链</h4><p><strong>作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</strong><br>理清作用域链可以帮助我们理解 js 很多问题包括闭包问题等，下面我们结合一个简单的例子来理解作用域链，如下：</p><pre><code>    var num = 30;    function test() &#123;    var a = 10;    function innerTest() &#123;        var b = 20;        return a + b;    &#125;    innerTest();    &#125;    test();</code></pre><p>在上面的例子中，当执行到调用 innerTest 函数，进入 innerTest 函数环境。全局执行上下文和 test 函数执行上下文已进入执行阶段，innerTest 函数执行上下文在预编译阶段创建变量对象，所以他们的活动对象和变量对象分别是 AO(global)，AO(test)和 VO(innerTest)，而 innerTest 的作用域链由当前执行环境的变量对象（未进入执行阶段前）与上层环境的一系列活动对象组成，如下：<br>innerTestEC = { //变量对象 VO: {b: undefined}, //作用域链 scopeChain: [VO(innerTest), AO(test), AO(global)], //this 指向 this: window}<br>我们这里直接使用数组表示作用域链，作用域链的活动对象或变量对象可以直接理解为作用域。<br>作用域链的第一项永远是当前作用域（当前上下文的变量对象或活动对象）；<br>最后一项永远是全局作用域（全局执行上下文的活动对象）；<br>作用域链保证了变量和函数的有序访问，查找方式是沿着作用域链从左至右查找变量或函数，找到则会停止查找，找不到则一直查找到全局作用域，再找不到则会抛出引用错误。<br>在这里我们顺便思考一下，什么是闭包？<br>我们先看下面一个简单例子，如下：</p><pre><code>    function foo() &#123;    var num = 20;    function bar() &#123;        var result = num + 20;        return result;    &#125;    bar();    &#125;    foo();</code></pre><p>因为对于闭包有很多不同的理解，包括我看的一些书籍(例如 js 高级程序设计)，我这里直接以浏览器解析，以浏览器理解的闭包为准来分析闭包，如下图：<br><img src="/imgs/js%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE5.jpeg"><br>如上图所示，chrome 浏览器理解闭包是 foo，那么按浏览器的标准是如何定义闭包的，我总结为三点：</p><ul><li><strong>在函数内部定义新函数</strong></li><li><strong>新函数访问外层函数的局部变量，即访问外层函数环境的活动对象属性</strong></li><li><strong>新函数执行，创建新的函数执行上下文，外层函数即为闭包</strong></li></ul><hr><p><strong>确定 this 指向</strong><br>在全局环境下，全局执行上下文中变量对象的 this 属性指向为 window；函数环境下的 this 指向却较为灵活，需根据执行环境和执行方法确定，需要举大量的典型例子概括，本文先不做分析。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于涉及的内容过多，这里将第三个阶段（<strong>执行阶段</strong>）单独分离出来。另开新文章进行详细分析，下篇文章主要介绍 js 执行阶段中的同步任务执行和异步任务执行机制（<strong>事件循环（Event Loop）</strong>）</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/28/hello-world/"/>
      <url>/2018/06/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code>$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code>$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code>$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code>$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
